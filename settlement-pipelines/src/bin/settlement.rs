use anchor_client::solana_client::rpc_config::RpcSendTransactionConfig;
use anchor_client::{Client, ClientError, Cluster, DynSigner};
use anyhow::anyhow;
use clap::Parser;
use env_logger::{Builder, Env};
use log::{debug, error, info};
use marinade_transactions::transaction_builder::TransactionBuilder;
use marinade_transactions::transaction_executors::execute_transaction_builder;
use regex::Regex;
use settlement_engine::merkle_tree_collection::MerkleTreeCollection;
use settlement_engine::utils::read_from_json_file;
use settlement_pipelines::{
    arguments::{load_keypair, GlobalOpts},
    constants::MARINADE_CONFIG_ADDRESS,
};
use solana_sdk::commitment_config::CommitmentConfig;
use solana_sdk::pubkey::Pubkey;
use solana_sdk::system_program;
use std::path::Path;
use std::str::FromStr;
use std::sync::Arc;
use validator_bonds::instructions::InitSettlementArgs;
use validator_bonds::state::bond::find_event_authority;
use validator_bonds::state::settlement::Settlement;
use validator_bonds::ID as validator_bonds_id;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[arg(
        short = 'i',
        long,
        env,
        help = "Merkle tree collection file path generated by settlement-engine as of --output-merkle-tree-collection"
    )]
    input_merkle_tree_collection: String,

    #[arg(long, default_value = MARINADE_CONFIG_ADDRESS)]
    config: Pubkey,

    #[arg(long)]
    epoch: Option<u64>,

    #[arg(short = 'o', long)]
    operator_authority: Option<String>,

    #[clap(flatten)]
    global_opts: GlobalOpts,
}

fn main() -> anyhow::Result<()> {
    let args: Args = Args::parse();

    let verbosity = if args.global_opts.verbose {
        "debug"
    } else {
        "info"
    };
    let mut builder = Builder::from_env(Env::default().default_filter_or(verbosity));
    builder.init();

    info!(
        "Loading merkle tree at: '{}', validator-bonds config: {}",
        args.input_merkle_tree_collection, args.config
    );
    let merkle_tree_collection: MerkleTreeCollection =
        read_from_json_file(&args.input_merkle_tree_collection)?;

    // Initialize the Anchor Solana client
    let rpc_url = args
        .global_opts
        .rpc_url
        .ok_or(anyhow!("RPC URL is required, provide --rpc-url argument"))?;
    let anchor_cluster = Cluster::from_str(&rpc_url)
        .map_err(|e| anyhow!("Could not parse JSON RPC url `{:?}`: {}", rpc_url, e))?;

    let keypair_keypair = load_keypair(&args.global_opts.keypair)?;
    let fee_payer_keypair = if let Some(fee_payer) = args.global_opts.fee_payer {
        load_keypair(&fee_payer)?
    } else {
        keypair_keypair.clone()
    };
    let operator_authority_keypair = if let Some(operator_authority) = args.operator_authority {
        load_keypair(&operator_authority)?
    } else {
        keypair_keypair.clone()
    };

    let epoch = args.epoch.map_or_else(|| {
        let merkle_file_name = Path::new(&args.input_merkle_tree_collection).file_name().unwrap()
            .to_str().ok_or(anyhow!("Cannot convert file name {} to string", args.input_merkle_tree_collection))?;
        let re = Regex::new("^(.)").unwrap();
        let captures = re.captures(merkle_file_name);
        captures
            .and_then(|c| c.get(0))
            .and_then(|m| m.as_str().parse::<u64>().ok())
            .ok_or(
                anyhow!("--epoch not provided and cannot extract epoch number from input merkle tree collection file path '{}'", args.input_merkle_tree_collection)
            )
    }, |v| Ok(v))?;

    let fee_payer_pubkey = fee_payer_keypair.pubkey();
    let anchor_client: Client<Arc<DynSigner>> = Client::new_with_options(
        anchor_cluster,
        Arc::new(DynSigner(fee_payer_keypair.clone())),
        CommitmentConfig {
            commitment: args.global_opts.commitment_level,
        },
    );
    let program = anchor_client.program(validator_bonds_id)?;

    let mut vote_accounts: Vec<Pubkey> = Vec::new();
    let mut transaction_builder = TransactionBuilder::limited(fee_payer_keypair.clone());
    transaction_builder.add_signer_checked(&operator_authority_keypair.clone());

    for merkle_tree in merkle_tree_collection.merkle_trees {
        let merkle_root = if let Some(merkle_root) = merkle_tree.merkle_root {
            merkle_root
        } else {
            // TODO: is logging error the right thing to do here?
            error!(
                "Cannot create for vote account {} without a merkle root",
                merkle_tree.vote_account
            );
            continue;
        };

        let (bond_address, _) = validator_bonds::state::bond::find_bond_address(
            &args.config,
            &merkle_tree.vote_account,
        );
        let (settlement_address, _) = validator_bonds::state::settlement::find_settlement_address(
            &bond_address,
            &merkle_root.to_bytes(),
            epoch,
        );

        // let's verify existence of the settlement account
        let settlement_data = program
            .account::<Settlement>(settlement_address.clone())
            .map_or_else(
                |e| match e {
                    ClientError::AccountNotFound => {
                        debug!("Settlement account {} not found: {}", settlement_address, e);
                        Ok(None)
                    }
                    _ => Err(anyhow!(
                        "Cannot get account data for settlement account {}: {}",
                        settlement_address,
                        e
                    )),
                },
                |a| Ok(Some(a)),
            )?;

        if let Some(settlement) = settlement_data {
            if settlement.merkle_root != merkle_root.to_bytes()
                || settlement.max_merkle_nodes != merkle_tree.max_total_claims as u64
                || settlement.max_total_claim != merkle_tree.max_total_claim_sum
            {
                return Err(anyhow!(
                    "Settlement account {} already exists but with different merkle data, json: [{:?}], on-chain: [{:?}]",
                    settlement_address,
                    (merkle_root.to_bytes(), merkle_tree.max_total_claims as u64, merkle_tree.max_total_claim_sum),
                    (settlement.merkle_root, settlement.max_merkle_nodes, settlement.max_total_claim)
                ));
            }
            debug!(
                "Settlement account {} already exists, skipping initialization",
                settlement_address
            );
            continue;
        }

        vote_accounts.push(merkle_tree.vote_account);
        let req = program
            .request()
            .accounts(validator_bonds::accounts::InitSettlement {
                config: args.config,
                bond: bond_address,
                operator_authority: operator_authority_keypair.pubkey(),
                system_program: system_program::ID,
                rent_payer: fee_payer_pubkey,
                program: validator_bonds_id,
                settlement: settlement_address,
                event_authority: find_event_authority().0,
            })
            .args(validator_bonds::instruction::InitSettlement {
                init_settlement_args: InitSettlementArgs {
                    merkle_root: merkle_root.to_bytes(),
                    rent_collector: fee_payer_pubkey,
                    max_total_claim: merkle_tree.max_total_claim_sum,
                    max_merkle_nodes: merkle_tree.max_total_claims as u64,
                    epoch,
                },
            });
        transaction_builder
            .add_instructions_from_builder(req)
            .map_err(|e| anyhow!("Cannot add instruction to transaction builder: {}", e))?;
    }

    if transaction_builder.instructions().len() == 0 {
        info!("No InitSettlement instructions to execute");
        return Ok(());
    } else {
        info!(
            "Execution of {} InitSettlement instructions of vote accounts [{}]",
            transaction_builder.instructions().len(),
            vote_accounts
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<String>>()
                .join(", ")
        );
        execute_transaction_builder(
            &mut transaction_builder,
            &program.rpc(),
            RpcSendTransactionConfig {
                skip_preflight: args.global_opts.skip_preflight,
                ..RpcSendTransactionConfig::default()
            },
            args.global_opts.commitment_level,
            false,
            false,
            Some(2),
        )?;
    }

    Ok(())
}
