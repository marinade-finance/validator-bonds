/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type Option,
  type OptionOrNullable,
  type ReadonlyUint8Array,
} from '@solana/kit'
import {
  getBumpsDecoder,
  getBumpsEncoder,
  type Bumps,
  type BumpsArgs,
} from '../types'

export const SETTLEMENT_DISCRIMINATOR = new Uint8Array([
  55, 11, 219, 33, 36, 136, 40, 182,
])

export function getSettlementDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(SETTLEMENT_DISCRIMINATOR)
}

export type Settlement = {
  discriminator: ReadonlyUint8Array
  /** the settlement belongs under this bond, i.e., under a particular validator vote account */
  bond: Address
  /**
   * settlement authority used as the 'staker' stake account authority
   * of stake accounts funded to this settlement
   */
  stakerAuthority: Address
  /** 256-bit merkle root to check the claims against */
  merkleRoot: ReadonlyUint8Array
  /** maximum number of funds that can ever be claimed */
  maxTotalClaim: bigint
  /** maximum number of merkle tree nodes that can ever be claimed */
  maxMerkleNodes: bigint
  /** total lamports funded */
  lamportsFunded: bigint
  /** total lamports that have been claimed */
  lamportsClaimed: bigint
  /** number of nodes that have been claimed */
  merkleNodesClaimed: bigint
  /** what epoch the Settlement has been created for */
  epochCreatedFor: bigint
  /** when the Settlement was created */
  slotCreatedAt: bigint
  /** address that collects the rent exempt from the Settlement account when closed */
  rentCollector: Address
  /** address that collects rent exempt for "split stake account" possibly created on funding settlement */
  splitRentCollector: Option<Address>
  /** amount of lamports that are collected for rent exempt for "split stake account" */
  splitRentAmount: bigint
  /** PDA bumps */
  bumps: Bumps
  /** reserve space for future extensions */
  reserved: ReadonlyUint8Array
}

export type SettlementArgs = {
  /** the settlement belongs under this bond, i.e., under a particular validator vote account */
  bond: Address
  /**
   * settlement authority used as the 'staker' stake account authority
   * of stake accounts funded to this settlement
   */
  stakerAuthority: Address
  /** 256-bit merkle root to check the claims against */
  merkleRoot: ReadonlyUint8Array
  /** maximum number of funds that can ever be claimed */
  maxTotalClaim: number | bigint
  /** maximum number of merkle tree nodes that can ever be claimed */
  maxMerkleNodes: number | bigint
  /** total lamports funded */
  lamportsFunded: number | bigint
  /** total lamports that have been claimed */
  lamportsClaimed: number | bigint
  /** number of nodes that have been claimed */
  merkleNodesClaimed: number | bigint
  /** what epoch the Settlement has been created for */
  epochCreatedFor: number | bigint
  /** when the Settlement was created */
  slotCreatedAt: number | bigint
  /** address that collects the rent exempt from the Settlement account when closed */
  rentCollector: Address
  /** address that collects rent exempt for "split stake account" possibly created on funding settlement */
  splitRentCollector: OptionOrNullable<Address>
  /** amount of lamports that are collected for rent exempt for "split stake account" */
  splitRentAmount: number | bigint
  /** PDA bumps */
  bumps: BumpsArgs
  /** reserve space for future extensions */
  reserved: ReadonlyUint8Array
}

export function getSettlementEncoder(): Encoder<SettlementArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['bond', getAddressEncoder()],
      ['stakerAuthority', getAddressEncoder()],
      ['merkleRoot', fixEncoderSize(getBytesEncoder(), 32)],
      ['maxTotalClaim', getU64Encoder()],
      ['maxMerkleNodes', getU64Encoder()],
      ['lamportsFunded', getU64Encoder()],
      ['lamportsClaimed', getU64Encoder()],
      ['merkleNodesClaimed', getU64Encoder()],
      ['epochCreatedFor', getU64Encoder()],
      ['slotCreatedAt', getU64Encoder()],
      ['rentCollector', getAddressEncoder()],
      ['splitRentCollector', getOptionEncoder(getAddressEncoder())],
      ['splitRentAmount', getU64Encoder()],
      ['bumps', getBumpsEncoder()],
      ['reserved', fixEncoderSize(getBytesEncoder(), 90)],
    ]),
    value => ({ ...value, discriminator: SETTLEMENT_DISCRIMINATOR }),
  )
}

export function getSettlementDecoder(): Decoder<Settlement> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['bond', getAddressDecoder()],
    ['stakerAuthority', getAddressDecoder()],
    ['merkleRoot', fixDecoderSize(getBytesDecoder(), 32)],
    ['maxTotalClaim', getU64Decoder()],
    ['maxMerkleNodes', getU64Decoder()],
    ['lamportsFunded', getU64Decoder()],
    ['lamportsClaimed', getU64Decoder()],
    ['merkleNodesClaimed', getU64Decoder()],
    ['epochCreatedFor', getU64Decoder()],
    ['slotCreatedAt', getU64Decoder()],
    ['rentCollector', getAddressDecoder()],
    ['splitRentCollector', getOptionDecoder(getAddressDecoder())],
    ['splitRentAmount', getU64Decoder()],
    ['bumps', getBumpsDecoder()],
    ['reserved', fixDecoderSize(getBytesDecoder(), 90)],
  ])
}

export function getSettlementCodec(): Codec<SettlementArgs, Settlement> {
  return combineCodec(getSettlementEncoder(), getSettlementDecoder())
}

export function decodeSettlement<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<Settlement, TAddress>
export function decodeSettlement<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<Settlement, TAddress>
export function decodeSettlement<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<Settlement, TAddress> | MaybeAccount<Settlement, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getSettlementDecoder(),
  )
}

export async function fetchSettlement<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<Settlement, TAddress>> {
  const maybeAccount = await fetchMaybeSettlement(rpc, address, config)
  assertAccountExists(maybeAccount)
  return maybeAccount
}

export async function fetchMaybeSettlement<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<Settlement, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config)
  return decodeSettlement(maybeAccount)
}

export async function fetchAllSettlement(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<Settlement>[]> {
  const maybeAccounts = await fetchAllMaybeSettlement(rpc, addresses, config)
  assertAccountsExist(maybeAccounts)
  return maybeAccounts
}

export async function fetchAllMaybeSettlement(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<Settlement>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config)
  return maybeAccounts.map(maybeAccount => decodeSettlement(maybeAccount))
}
