#!/usr/bin/env bash
#
# Regression test for settlement generation pipeline.
#
# Downloads input data from GCS / scoring API, runs bid-distribution-cli,
# institutional-distribution-cli and merkle-generator-cli, then compares
# outputs against production results already stored in GCS.
#
# Files are cached in --data-dir so subsequent runs (e.g. after code changes)
# reuse previously downloaded data and only re-generate the "actual" outputs.
#
# Usage:
#   ./scripts/regression-test-settlements.sh \
#       --start-epoch 918 --end-epoch 918 --data-dir ./regression-data
#
# Cache directory layout per epoch:
#
#   <data-dir>/<epoch>/inputs/
#     stakes.json                              # GCS: marinade-validator-bonds-mainnet
#     sam-scores.json                          # scoring API
#     validators.json                          # GCS: marinade-validator-bonds-mainnet
#     evaluation.json                          # GCS: bid-psr-distribution-evaluation.json
#     rewards/{mev,inflation,...}.json          # GCS: marinade-stakes-etl-mainnet
#     institutional/
#       institutional-payouts.json             # GCS: marinade-institutional-staking-mainnet
#       stakes.json                            # GCS: marinade-solana-snapshot-mainnet
#
#   <data-dir>/<epoch>/expected/               # production outputs (auto-detected format)
#     OLD format (epochs ≤927, separate SAM+PSR pipelines):
#       bid-distribution-settlements.json
#       bid-psr-distribution-settlements.json
#       bid-distribution-settlement-merkle-trees.json
#       bid-psr-distribution-settlement-merkle-trees.json
#       institutional-distribution-settlements.json
#       institutional-distribution-settlement-merkle-trees.json
#     NEW format (epochs ≥928, unified pipeline):
#       bid-distribution-settlements.json          (combined SAM+PSR)
#       unified-merkle-trees.json
#       institutional-distribution-settlements.json
#       institutional-distribution-merkle-trees.json
#
#   <data-dir>/<epoch>/actual/                 # generated by current code
#     bid-distribution-settlements.json          (combined SAM+PSR)
#     unified-merkle-trees.json
#     institutional-distribution-settlements.json
#     institutional-merkle-trees.json
#

# NOTE: pipefail is required -- the `if ! cmd 2>&1 | tail` pattern below
# checks the exit code of the pipeline's first command (not tail).
set -euo pipefail

# ---------------------------------------------------------------------------
# Defaults
# ---------------------------------------------------------------------------
GS_BUCKET="gs://marinade-validator-bonds-mainnet"
GS_BUCKET_ETL="gs://marinade-stakes-etl-mainnet"
GS_BUCKET_INSTITUTIONAL="gs://marinade-institutional-staking-mainnet"
GS_BUCKET_SNAPSHOT="gs://marinade-solana-snapshot-mainnet"
SCORING_API_URL="https://scoring.marinade.finance/api/v1"
DATA_DIR="./regression-data"
START_EPOCH=""
END_EPOCH=""
BID_BONDS_CONFIG="vbMaRfmTCg92HWGzmd53APkMNpPnGVGZTUHwUJQkXAU"
INST_BONDS_CONFIG="VbinSTyUEC8JXtzFteC4ruKSfs6dkQUUcY6wB1oJyjE"
# Institutional fee authorities (from pipeline env)
INST_MARINADE_FEE_STAKE_AUTHORITY="BBaQsiRo744NAYaqL3nKRfgeJayoqVicEQsEnLpfsJ6x"
INST_MARINADE_FEE_WITHDRAW_AUTHORITY="BBaQsiRo744NAYaqL3nKRfgeJayoqVicEQsEnLpfsJ6x"
INST_DAO_FEE_SPLIT_SHARE_BPS="10000"
INST_DAO_FEE_STAKE_AUTHORITY="mDAo14E6YJfEHcVZLcc235RVjviypmKMhftq7jeiLJz"
INST_DAO_FEE_WITHDRAW_AUTHORITY="mDAo14E6YJfEHcVZLcc235RVjviypmKMhftq7jeiLJz"

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# ---------------------------------------------------------------------------
# Parse arguments
# ---------------------------------------------------------------------------
while [[ $# -gt 0 ]]; do
  case "$1" in
    --start-epoch)      START_EPOCH="$2";       shift 2 ;;
    --end-epoch)        END_EPOCH="$2";         shift 2 ;;
    --data-dir)         DATA_DIR="$2";          shift 2 ;;
    --scoring-api-url)  SCORING_API_URL="$2";   shift 2 ;;
    -h|--help)
      echo "Usage: $0 [--start-epoch N] [--end-epoch N] [--data-dir DIR] [--scoring-api-url URL]"
      echo ""
      echo "  --start-epoch N       First epoch to test (default: auto-detect last 30 from GCS)"
      echo "  --end-epoch N         Last epoch to test  (default: auto-detect latest from GCS)"
      echo "  --data-dir DIR        Cache directory for downloaded data (default: ./regression-data)"
      echo "  --scoring-api-url URL SAM scoring API base URL"
      echo "                        (default: https://scoring.marinade.finance/api/v1)"
      exit 0
      ;;
    *) echo "Unknown option: $1"; exit 1 ;;
  esac
done

# ---------------------------------------------------------------------------
# Auto-detect epoch range from GCS if not specified
# ---------------------------------------------------------------------------
auto_detect_epochs() {
  echo "Auto-detecting available epochs from GCS..."
  local epochs
  epochs=$(gcloud storage ls "$GS_BUCKET/" \
    | sed -n 's|.*'"$GS_BUCKET"'/\([0-9]\{1,\}\)/|\1|p' \
    | sort -n)

  if [[ -z "$epochs" ]]; then
    echo "ERROR: Could not list epochs from $GS_BUCKET"
    exit 1
  fi

  local latest
  latest=$(echo "$epochs" | tail -1)

  if [[ -z "$END_EPOCH" ]]; then
    END_EPOCH="$latest"
  fi
  if [[ -z "$START_EPOCH" ]]; then
    local earliest
    earliest=$(echo "$epochs" | head -1)
    START_EPOCH=$(( END_EPOCH - 30 ))
    if (( START_EPOCH < earliest )); then
      START_EPOCH="$earliest"
    fi
  fi

  echo "Epoch range: $START_EPOCH .. $END_EPOCH"
}

if [[ -z "$START_EPOCH" || -z "$END_EPOCH" ]]; then
  auto_detect_epochs
fi

# ---------------------------------------------------------------------------
# Ensure binaries are built
# ---------------------------------------------------------------------------
BID_CLI="$REPO_ROOT/target/release/bid-distribution-cli"
INST_CLI="$REPO_ROOT/target/release/institutional-distribution-cli"
MERKLE_CLI="$REPO_ROOT/target/release/merkle-generator-cli"

if [[ ! -x "$BID_CLI" || ! -x "$MERKLE_CLI" || ! -x "$INST_CLI" ]]; then
  echo "Binaries not found. Building..."
  (cd "$REPO_ROOT" && cargo build --release \
    --bin bid-distribution-cli \
    --bin institutional-distribution-cli \
    --bin merkle-generator-cli)
fi

SETTLEMENT_CONFIG="$REPO_ROOT/settlement-config.yaml"
if [[ ! -f "$SETTLEMENT_CONFIG" ]]; then
  echo "ERROR: settlement-config.yaml not found at $SETTLEMENT_CONFIG"
  exit 1
fi

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

# Download a file from GCS if it doesn't already exist locally.
gcs_cached_download() {
  local gcs_path="$1"
  local local_path="$2"
  if [[ -f "$local_path" ]]; then
    return 0
  fi
  mkdir -p "$(dirname "$local_path")"
  if gcloud storage cp "$gcs_path" "$local_path" 2>/dev/null; then
    return 0
  else
    echo "  WARN: failed to download $gcs_path"
    return 1
  fi
}

# Download from an HTTP URL if the local file doesn't already exist.
http_cached_download() {
  local url="$1"
  local local_path="$2"
  if [[ -f "$local_path" ]]; then
    return 0
  fi
  mkdir -p "$(dirname "$local_path")"
  if curl -sf "$url" -o "$local_path"; then
    return 0
  else
    echo "  WARN: failed to download $url"
    rm -f "$local_path"
    return 1
  fi
}

# Sum claims_amount across all settlements in a JSON file.
# Usage: sum_claims <file> [<file2> ...]
sum_claims() {
  jq -n "[inputs.settlements[].claims_amount] | add" "$@" 2>/dev/null || echo "null"
}

# Per-vote-account claim totals as sorted JSON: [{vote_account, total}]
# Usage: per_vote_claims <file> [<file2> ...]
per_vote_claims() {
  jq -n '
    [inputs.settlements[] | {vote_account, claims_amount}]
    | group_by(.vote_account)
    | map({vote_account: .[0].vote_account, total: (map(.claims_amount) | add)})
    | sort_by(.vote_account)
  ' "$@" 2>/dev/null || echo "null"
}

# Per-vote-account per-funder claim totals from settlement collections as sorted JSON:
#   [{vote_account, funder, total}]
# Usage: per_vote_funder_claims <file> [<file2> ...]
per_vote_funder_claims() {
  jq -n '
    [inputs.settlements[] | {vote_account, funder: .meta.funder, claims_amount}]
    | group_by([.vote_account, .funder])
    | map({vote_account: .[0].vote_account, funder: .[0].funder, total: (map(.claims_amount) | add)})
    | sort_by([.vote_account, .funder])
  ' "$@" 2>/dev/null || echo "null"
}

# Per-vote-account per-funder funding amounts from merkle tree JSON as sorted JSON:
#   [{vote_account, funder, total}]
# Usage: merkle_tree_funding_sources <merkle-tree-file>
merkle_tree_funding_sources() {
  jq '
    [.merkle_trees[] | .vote_account as $va |
      (.funding_sources // {}) | to_entries[] |
      {vote_account: $va, funder: .key, total: .value}
    ] | sort_by([.vote_account, .funder])
  ' "$1" 2>/dev/null || echo "null"
}

# Verify funding integrity of a merkle tree JSON file.
# Checks that each tree has exactly one funder and its amount equals max_total_claim_sum.
# This guarantees init_settlement creates correct PDAs and fund_settlement funds from
# the right source (bond stake for ValidatorBond, marinade wallet for Marinade).
# Usage: check_funding_integrity <merkle-tree-file> <label-prefix>
# Returns 0 on pass, 1 on failure. Prints results to stdout.
check_funding_integrity() {
  local merkle_file="$1"
  local prefix="$2"

  # Find trees with != 1 funding_sources entry (multi-funder or missing)
  local bad_funder_count
  bad_funder_count=$(jq '
    [.merkle_trees[] | select((.funding_sources // {} | length) != 1)]
    | length
  ' "$merkle_file" 2>/dev/null || echo "ERROR")

  if [[ "$bad_funder_count" == "ERROR" ]]; then
    echo "  ${prefix}ERROR: could not check funding integrity"
    return 1
  elif [[ "$bad_funder_count" -ne 0 ]]; then
    echo "  ${prefix}FAIL funding integrity: $bad_funder_count trees have != 1 funder (multi-funder or empty)"
    jq -r '
      [.merkle_trees[] | select((.funding_sources // {} | length) != 1)
       | {vote_account, funding_sources, max_total_claim_sum}]
      | .[:5][] | "\(.vote_account) sources=\(.funding_sources) claim_sum=\(.max_total_claim_sum)"
    ' "$merkle_file" 2>/dev/null || true
    return 1
  fi

  # Verify each tree's single funder amount == max_total_claim_sum
  local amount_mismatch
  amount_mismatch=$(jq '
    [.merkle_trees[] |
      (.funding_sources // {} | to_entries | .[0].value) as $funder_amount |
      select($funder_amount != .max_total_claim_sum)
    ] | length
  ' "$merkle_file" 2>/dev/null || echo "ERROR")

  if [[ "$amount_mismatch" == "ERROR" ]]; then
    echo "  ${prefix}ERROR: could not check funding amounts"
    return 1
  elif [[ "$amount_mismatch" -ne 0 ]]; then
    echo "  ${prefix}FAIL funding integrity: $amount_mismatch trees have funder amount != max_total_claim_sum"
    jq -r '
      [.merkle_trees[] |
        (.funding_sources // {} | to_entries | .[0]) as $fs |
        select($fs.value != .max_total_claim_sum)
      | {vote_account, funder: $fs.key, funder_amount: $fs.value, max_total_claim_sum}]
      | .[:5][] | "\(.vote_account) \(.funder)=\(.funder_amount) claim_sum=\(.max_total_claim_sum)"
    ' "$merkle_file" 2>/dev/null || true
    return 1
  fi

  local tree_count marinade_count bond_count
  tree_count=$(jq '.merkle_trees | length' "$merkle_file")
  marinade_count=$(jq '[.merkle_trees[] | select(.funding_sources | has("Marinade"))] | length' "$merkle_file")
  bond_count=$(jq '[.merkle_trees[] | select(.funding_sources | has("ValidatorBond"))] | length' "$merkle_file")
  echo "  ${prefix}OK funding integrity: $tree_count trees ($bond_count ValidatorBond, $marinade_count Marinade) — each single-funder, amounts consistent"
  return 0
}

# ---------------------------------------------------------------------------
# Per-epoch processing
# ---------------------------------------------------------------------------
results=()

process_epoch() {
  local epoch="$1"
  local epoch_dir="$DATA_DIR/$epoch"
  local inputs_dir="$epoch_dir/inputs"
  local rewards_dir="$inputs_dir/rewards"
  local inst_inputs_dir="$inputs_dir/institutional"
  local expected_dir="$epoch_dir/expected"
  local actual_dir="$epoch_dir/actual"

  echo ""
  echo "================================================================"
  echo "  Epoch $epoch"
  echo "================================================================"

  mkdir -p "$inputs_dir" "$rewards_dir" "$inst_inputs_dir" "$expected_dir" "$actual_dir"

  # =====================================================================
  # BID DISTRIBUTION (SAM + PSR)
  # =====================================================================

  # ------- Download bid inputs (cached) -----------------------------------

  echo "Downloading bid-distribution inputs..."
  local missing_bid_input=false

  gcs_cached_download "$GS_BUCKET/$epoch/stakes.json" "$inputs_dir/stakes.json" \
    || missing_bid_input=true
  http_cached_download "$SCORING_API_URL/scores/sam?epoch=$epoch" "$inputs_dir/sam-scores.json" \
    || missing_bid_input=true
  gcs_cached_download "$GS_BUCKET/$epoch/validators.json" "$inputs_dir/validators.json" \
    || missing_bid_input=true
  gcs_cached_download "$GS_BUCKET/$epoch/bid-psr-distribution-evaluation.json" "$inputs_dir/evaluation.json" \
    || missing_bid_input=true

  # Rewards: GCS rewards_X.json -> local X.json (names match Rust constants)
  gcs_cached_download "$GS_BUCKET_ETL/$epoch/rewards_mev.json" "$rewards_dir/mev.json" \
    || missing_bid_input=true
  gcs_cached_download "$GS_BUCKET_ETL/$epoch/rewards_validators_mev.json" "$rewards_dir/validators_mev.json" \
    || missing_bid_input=true
  gcs_cached_download "$GS_BUCKET_ETL/$epoch/rewards_inflation.json" "$rewards_dir/inflation.json" \
    || missing_bid_input=true
  gcs_cached_download "$GS_BUCKET_ETL/$epoch/rewards_validators_inflation.json" "$rewards_dir/validators_inflation.json" \
    || missing_bid_input=true
  gcs_cached_download "$GS_BUCKET_ETL/$epoch/rewards_validators_blocks.json" "$rewards_dir/validators_blocks.json" \
    || missing_bid_input=true
  gcs_cached_download "$GS_BUCKET_ETL/$epoch/rewards_priority_fee.json" "$rewards_dir/jito_priority_fee.json" \
    || missing_bid_input=true

  # ------- Download bid expected outputs (cached) -------------------------
  # Auto-detect epoch format by probing for the new-format marker file.

  echo "Downloading bid-distribution expected outputs..."
  local missing_bid_expected=false
  local epoch_format

  if [[ -f "$expected_dir/unified-merkle-trees.json" ]] || \
     gcloud storage cp "$GS_BUCKET/$epoch/unified-merkle-trees.json" \
       "$expected_dir/unified-merkle-trees.json" 2>/dev/null; then
    epoch_format="new"
    echo "  Detected NEW format (unified) for epoch $epoch"
    gcs_cached_download "$GS_BUCKET/$epoch/bid-distribution-settlements.json" \
      "$expected_dir/bid-distribution-settlements.json" \
      || missing_bid_expected=true
  else
    epoch_format="old"
    echo "  Detected OLD format (separate SAM+PSR) for epoch $epoch"
    gcs_cached_download "$GS_BUCKET/$epoch/bid-distribution-settlements.json" \
      "$expected_dir/bid-distribution-settlements.json" \
      || missing_bid_expected=true
    gcs_cached_download "$GS_BUCKET/$epoch/bid-psr-distribution-settlements.json" \
      "$expected_dir/bid-psr-distribution-settlements.json" \
      || missing_bid_expected=true
    gcs_cached_download "$GS_BUCKET/$epoch/bid-distribution-settlement-merkle-trees.json" \
      "$expected_dir/bid-distribution-settlement-merkle-trees.json" \
      || missing_bid_expected=true
    gcs_cached_download "$GS_BUCKET/$epoch/bid-psr-distribution-settlement-merkle-trees.json" \
      "$expected_dir/bid-psr-distribution-settlement-merkle-trees.json" \
      || missing_bid_expected=true
  fi

  # ------- Run bid-distribution-cli ---------------------------------------

  local bid_claims_status="SKIP" bid_merkle_status="SKIP"

  if [[ "$missing_bid_input" == "true" || "$missing_bid_expected" == "true" ]]; then
    echo "  SKIP bid-distribution: missing input or expected files"
  else
    echo "Running bid-distribution-cli..."
    rm -f "$actual_dir/bid-distribution-settlements.json" \
          "$actual_dir/protected-events.json"

    if ! "$BID_CLI" \
        --settlement-config "$SETTLEMENT_CONFIG" \
        --stake-meta-collection "$inputs_dir/stakes.json" \
        --sam-meta-collection "$inputs_dir/sam-scores.json" \
        --rewards-dir "$rewards_dir" \
        --validator-meta-collection "$inputs_dir/validators.json" \
        --revenue-expectation-collection "$inputs_dir/evaluation.json" \
        --output-settlement-collection "$actual_dir/bid-distribution-settlements.json" \
        --output-protected-event-collection "$actual_dir/protected-events.json" \
        2>&1 | tail -5; then
      echo "  FAIL: bid-distribution-cli error"
      bid_claims_status="ERROR"; bid_merkle_status="ERROR"
    else
      echo "Running merkle-generator-cli (bid)..."
      rm -f "$actual_dir/unified-merkle-trees.json"

      if ! "$MERKLE_CLI" \
          --input-settlement-files "$actual_dir/bid-distribution-settlements.json" \
          --output-merkle-trees "$actual_dir/unified-merkle-trees.json" \
          --validator-bonds-config "$BID_BONDS_CONFIG" \
          2>&1 | tail -3; then
        echo "  FAIL: merkle-generator-cli (bid) error"
        bid_claims_status="ERROR"; bid_merkle_status="ERROR"
      else
        # ---------- Compare bid settlements ----------------------------------
        bid_claims_status="MATCH"
        bid_merkle_status="MATCH"

        if [[ "$epoch_format" == "new" ]]; then
          # --- NEW format: direct comparison (same structure on both sides) ---

          # 1) Settlement count
          local exp_count act_count
          exp_count=$(jq '.settlements | length' "$expected_dir/bid-distribution-settlements.json")
          act_count=$(jq '.settlements | length' "$actual_dir/bid-distribution-settlements.json")

          if [[ "$act_count" -ne "$exp_count" ]]; then
            echo "  FAIL settlement count: expected $exp_count, got $act_count"
            bid_claims_status="DIFFER"
          else
            echo "  OK settlement count: $act_count"
          fi

          # 2) Total claims amount
          local exp_claims act_claims
          exp_claims=$(sum_claims "$expected_dir/bid-distribution-settlements.json")
          act_claims=$(sum_claims "$actual_dir/bid-distribution-settlements.json")

          if [[ "$exp_claims" == "null" || "$act_claims" == "null" ]]; then
            echo "  ERROR: could not compute claim sums"
            bid_claims_status="ERROR"
          elif [[ "$exp_claims" -ne "$act_claims" ]]; then
            echo "  FAIL total claims: expected $exp_claims, got $act_claims (diff: $(( act_claims - exp_claims )))"
            bid_claims_status="DIFFER"
          else
            echo "  OK total claims amount: $act_claims lamports"
          fi

          # 3) Per-vote-account claims
          local exp_per_vote act_per_vote
          exp_per_vote=$(per_vote_claims "$expected_dir/bid-distribution-settlements.json")
          act_per_vote=$(per_vote_claims "$actual_dir/bid-distribution-settlements.json")

          if [[ "$exp_per_vote" == "null" || "$act_per_vote" == "null" ]]; then
            echo "  ERROR: could not compute per-vote claims"
            [[ "$bid_claims_status" == "MATCH" ]] && bid_claims_status="ERROR"
          elif [[ "$exp_per_vote" != "$act_per_vote" ]]; then
            local diff_votes
            diff_votes=$(diff <(echo "$exp_per_vote" | jq -r '.[] | "\(.vote_account) \(.total)"') \
                              <(echo "$act_per_vote" | jq -r '.[] | "\(.vote_account) \(.total)"') \
                         || true)
            local diff_count
            diff_count=$(echo "$diff_votes" | awk '/^[<>]/ {print $2}' | sort -u | wc -l || true)
            echo "  FAIL per-vote claims: $diff_count vote accounts differ"
            echo "$diff_votes" | head -10
            [[ "$bid_claims_status" == "MATCH" ]] && bid_claims_status="DIFFER"
          else
            echo "  OK per-vote-account claims all match"
          fi

          # 4) Merkle roots (direct comparison)
          local exp_roots act_roots
          exp_roots=$(jq -r '.merkle_trees[] | "\(.vote_account) \(.merkle_root | @json)"' \
            "$expected_dir/unified-merkle-trees.json" | sort)
          act_roots=$(jq -r '.merkle_trees[] | "\(.vote_account) \(.merkle_root | @json)"' \
            "$actual_dir/unified-merkle-trees.json" | sort)

          local root_total root_diff
          root_total=$(echo -n "$exp_roots" | grep -c '' || true)
          root_diff=$(diff <(echo "$exp_roots") <(echo "$act_roots") | grep -c '^[<>]' || true)
          root_diff=$(( root_diff / 2 ))

          if [[ "$root_diff" -eq 0 ]]; then
            echo "  OK merkle roots: all $root_total match"
          else
            echo "  FAIL merkle roots: $root_diff/$root_total differ"
            bid_merkle_status="DIFFER"
          fi

          # 5) Per-funder amounts
          local exp_funder act_funder
          exp_funder=$(per_vote_funder_claims "$expected_dir/bid-distribution-settlements.json")
          act_funder=$(merkle_tree_funding_sources "$actual_dir/unified-merkle-trees.json")

          if [[ "$exp_funder" == "null" || "$act_funder" == "null" ]]; then
            echo "  WARN: could not compute per-funder amounts (skipping check)"
          elif [[ "$exp_funder" != "$act_funder" ]]; then
            local funder_diff_count
            funder_diff_count=$(diff \
              <(echo "$exp_funder" | jq -r '.[] | "\(.vote_account) \(.funder) \(.total)"') \
              <(echo "$act_funder" | jq -r '.[] | "\(.vote_account) \(.funder) \(.total)"') \
              | grep -c '^[<>]' || true)
            funder_diff_count=$(( funder_diff_count / 2 ))
            echo "  FAIL per-funder amounts: $funder_diff_count entries differ"
            diff \
              <(echo "$exp_funder" | jq -r '.[] | "\(.vote_account) \(.funder) \(.total)"') \
              <(echo "$act_funder" | jq -r '.[] | "\(.vote_account) \(.funder) \(.total)"') \
              | head -10 || true
            [[ "$bid_claims_status" == "MATCH" ]] && bid_claims_status="DIFFER"
          else
            local funder_entries
            funder_entries=$(echo "$act_funder" | jq 'length')
            echo "  OK per-funder amounts: all $funder_entries entries match"
          fi

          # 6) Funding integrity
          if ! check_funding_integrity "$actual_dir/unified-merkle-trees.json" ""; then
            bid_merkle_status="DIFFER"
          fi

        else
          # --- OLD format: cross-format comparison (separate SAM+PSR vs unified) ---

          # 1) Settlement count: old SAM + old PSR == new unified
        local exp_sam_count exp_psr_count act_count
        exp_sam_count=$(jq '.settlements | length' "$expected_dir/bid-distribution-settlements.json")
        exp_psr_count=$(jq '.settlements | length' "$expected_dir/bid-psr-distribution-settlements.json")
        act_count=$(jq '.settlements | length' "$actual_dir/bid-distribution-settlements.json")
        local exp_total_count=$(( exp_sam_count + exp_psr_count ))

        if [[ "$act_count" -ne "$exp_total_count" ]]; then
          echo "  FAIL settlement count: expected $exp_sam_count SAM + $exp_psr_count PSR = $exp_total_count, got $act_count"
          bid_claims_status="DIFFER"
        else
          echo "  OK settlement count: $exp_sam_count SAM + $exp_psr_count PSR = $act_count"
        fi

        # 2) Total claims amount: sum across old SAM + PSR == sum across new
        local exp_claims act_claims
        exp_claims=$(sum_claims \
          "$expected_dir/bid-distribution-settlements.json" \
          "$expected_dir/bid-psr-distribution-settlements.json")
        act_claims=$(sum_claims "$actual_dir/bid-distribution-settlements.json")

        if [[ "$exp_claims" == "null" || "$act_claims" == "null" ]]; then
          echo "  ERROR: could not compute claim sums"
          bid_claims_status="ERROR"
        elif [[ "$exp_claims" -ne "$act_claims" ]]; then
          echo "  FAIL total claims: expected $exp_claims, got $act_claims (diff: $(( act_claims - exp_claims )))"
          bid_claims_status="DIFFER"
        else
          echo "  OK total claims amount: $act_claims lamports"
        fi

        # 3) Per-vote-account claims: sum per vote_account must match
        local exp_per_vote act_per_vote
        exp_per_vote=$(per_vote_claims \
          "$expected_dir/bid-distribution-settlements.json" \
          "$expected_dir/bid-psr-distribution-settlements.json")
        act_per_vote=$(per_vote_claims "$actual_dir/bid-distribution-settlements.json")

        if [[ "$exp_per_vote" == "null" || "$act_per_vote" == "null" ]]; then
          echo "  ERROR: could not compute per-vote claims"
          [[ "$bid_claims_status" == "MATCH" ]] && bid_claims_status="ERROR"
        elif [[ "$exp_per_vote" != "$act_per_vote" ]]; then
          # Show which vote accounts differ
          local diff_votes
          diff_votes=$(diff <(echo "$exp_per_vote" | jq -r '.[] | "\(.vote_account) \(.total)"') \
                            <(echo "$act_per_vote" | jq -r '.[] | "\(.vote_account) \(.total)"') \
                       || true)
          local diff_count
          diff_count=$(echo "$diff_votes" | awk '/^[<>]/ {print $2}' | sort -u | wc -l || true)
          echo "  FAIL per-vote claims: $diff_count vote accounts differ"
          echo "$diff_votes" | head -10
          [[ "$bid_claims_status" == "MATCH" ]] && bid_claims_status="DIFFER"
        else
          echo "  OK per-vote-account claims all match"
        fi

        # 4) Merkle roots for SAM-only vote accounts
        # The new unified merkle generator merges claims for the same
        # vote_account across settlement types into one tree.  So only
        # vote_accounts with ONLY SAM settlements can be compared directly.
        # PSR-overlapping vote accounts will have different roots because
        # their trees now include PSR claims — this is expected.
        local psr_vote_accounts
        psr_vote_accounts=$(jq -r '.settlements[].vote_account' \
          "$expected_dir/bid-psr-distribution-settlements.json" | sort -u)

        # Use @json for consistent array formatting (tostring is unreliable)
        local exp_sam_roots act_roots
        exp_sam_roots=$(jq -r '.merkle_trees[] | "\(.vote_account) \(.merkle_root | @json)"' \
          "$expected_dir/bid-distribution-settlement-merkle-trees.json" | sort)
        act_roots=$(jq -r '.merkle_trees[] | "\(.vote_account) \(.merkle_root | @json)"' \
          "$actual_dir/unified-merkle-trees.json" | sort)

        # Filter out PSR-overlapping vote accounts for root comparison
        local sam_only_exp sam_only_act
        if [[ -n "$psr_vote_accounts" ]]; then
          local psr_grep_pattern
          psr_grep_pattern=$(echo "$psr_vote_accounts" | paste -sd'|')
          sam_only_exp=$(echo "$exp_sam_roots" | grep -vE "^($psr_grep_pattern) " || true)
          sam_only_act=$(echo "$act_roots" | grep -vE "^($psr_grep_pattern) " || true)
        else
          sam_only_exp="$exp_sam_roots"
          sam_only_act="$act_roots"
        fi

        local sam_only_total sam_only_diff
        sam_only_total=$(echo -n "$sam_only_exp" | grep -c '' || true)
        sam_only_diff=$(diff <(echo "$sam_only_exp") <(echo "$sam_only_act") | grep -c '^[<>]' || true)
        # Each differing line produces a '<' and a '>' line
        sam_only_diff=$(( sam_only_diff / 2 ))

        if [[ "$sam_only_diff" -eq 0 ]]; then
          echo "  OK SAM-only merkle roots: all $sam_only_total match"
        else
          echo "  FAIL SAM-only merkle roots: $sam_only_diff/$sam_only_total differ"
          bid_merkle_status="DIFFER"
        fi

        # Report on PSR-overlapping vote accounts (expected to differ)
        local psr_overlap_count
        psr_overlap_count=$(echo "$psr_vote_accounts" | grep -c . || true)
        if [[ "$psr_overlap_count" -gt 0 ]]; then
          echo "  INFO $psr_overlap_count vote accounts have PSR settlements (merkle roots expected to differ due to claim merging)"
        fi

        # 5) Per-funder amounts: settlement collections per-vote per-funder == merkle tree funding_sources
        local exp_funder act_funder
        exp_funder=$(per_vote_funder_claims \
          "$expected_dir/bid-distribution-settlements.json" \
          "$expected_dir/bid-psr-distribution-settlements.json")
        act_funder=$(merkle_tree_funding_sources "$actual_dir/unified-merkle-trees.json")

        if [[ "$exp_funder" == "null" || "$act_funder" == "null" ]]; then
          echo "  WARN: could not compute per-funder amounts (skipping check)"
        elif [[ "$exp_funder" != "$act_funder" ]]; then
          local funder_diff_count
          funder_diff_count=$(diff \
            <(echo "$exp_funder" | jq -r '.[] | "\(.vote_account) \(.funder) \(.total)"') \
            <(echo "$act_funder" | jq -r '.[] | "\(.vote_account) \(.funder) \(.total)"') \
            | grep -c '^[<>]' || true)
          funder_diff_count=$(( funder_diff_count / 2 ))
          echo "  FAIL per-funder amounts: $funder_diff_count entries differ"
          diff \
            <(echo "$exp_funder" | jq -r '.[] | "\(.vote_account) \(.funder) \(.total)"') \
            <(echo "$act_funder" | jq -r '.[] | "\(.vote_account) \(.funder) \(.total)"') \
            | head -10 || true
          [[ "$bid_claims_status" == "MATCH" ]] && bid_claims_status="DIFFER"
        else
          local funder_entries
          funder_entries=$(echo "$act_funder" | jq 'length')
          echo "  OK per-funder amounts: all $funder_entries entries match"
        fi

        # 6) Funding integrity: each tree must have exactly one funder with amount == max_total_claim_sum
        #    This guarantees from_funding_sources() correctly classifies each settlement and
        #    fund_settlement funds ValidatorBond trees from bond stake, Marinade trees from Marinade wallet.
        if ! check_funding_integrity "$actual_dir/unified-merkle-trees.json" ""; then
          bid_merkle_status="DIFFER"
        fi
        fi # epoch_format branch
      fi
    fi
  fi

  # =====================================================================
  # INSTITUTIONAL DISTRIBUTION
  # =====================================================================

  echo "Downloading institutional inputs..."
  local missing_inst_input=false

  gcs_cached_download "$GS_BUCKET_INSTITUTIONAL/$epoch/institutional-payouts.json" \
    "$inst_inputs_dir/institutional-payouts.json" \
    || missing_inst_input=true
  gcs_cached_download "$GS_BUCKET_SNAPSHOT/$epoch/stakes.json" \
    "$inst_inputs_dir/stakes.json" \
    || missing_inst_input=true

  echo "Downloading institutional expected outputs..."
  local missing_inst_expected=false

  gcs_cached_download "$GS_BUCKET/$epoch/institutional-distribution-settlements.json" \
    "$expected_dir/institutional-distribution-settlements.json" \
    || missing_inst_expected=true
  local inst_expected_merkle_name
  if [[ "$epoch_format" == "new" ]]; then
    inst_expected_merkle_name="institutional-distribution-merkle-trees.json"
  else
    inst_expected_merkle_name="institutional-distribution-settlement-merkle-trees.json"
  fi
  gcs_cached_download "$GS_BUCKET/$epoch/$inst_expected_merkle_name" \
    "$expected_dir/$inst_expected_merkle_name" \
    || missing_inst_expected=true

  local inst_claims_status="SKIP" inst_merkle_status="SKIP"

  if [[ "$missing_inst_input" == "true" || "$missing_inst_expected" == "true" ]]; then
    echo "  SKIP institutional: missing input or expected files"
  else
    echo "Running institutional-distribution-cli..."
    rm -f "$actual_dir/institutional-distribution-settlements.json" \
          "$actual_dir/institutional-distribution-config.json"

    if ! "$INST_CLI" \
        --institutional-payouts "$inst_inputs_dir/institutional-payouts.json" \
        --stake-meta-collection "$inst_inputs_dir/stakes.json" \
        --marinade-fee-stake-authority "$INST_MARINADE_FEE_STAKE_AUTHORITY" \
        --marinade-fee-withdraw-authority "$INST_MARINADE_FEE_WITHDRAW_AUTHORITY" \
        --dao-fee-split-share-bps "$INST_DAO_FEE_SPLIT_SHARE_BPS" \
        --dao-fee-stake-authority "$INST_DAO_FEE_STAKE_AUTHORITY" \
        --dao-fee-withdraw-authority "$INST_DAO_FEE_WITHDRAW_AUTHORITY" \
        --output-settlement-collection "$actual_dir/institutional-distribution-settlements.json" \
        --output-config "$actual_dir/institutional-distribution-config.json" \
        2>&1 | tail -5; then
      echo "  FAIL: institutional-distribution-cli error"
      inst_claims_status="ERROR"; inst_merkle_status="ERROR"
    else
      echo "Running merkle-generator-cli (institutional)..."
      rm -f "$actual_dir/institutional-merkle-trees.json"

      if ! "$MERKLE_CLI" \
          --input-settlement-files "$actual_dir/institutional-distribution-settlements.json" \
          --output-merkle-trees "$actual_dir/institutional-merkle-trees.json" \
          --validator-bonds-config "$INST_BONDS_CONFIG" \
          2>&1 | tail -3; then
        echo "  FAIL: merkle-generator-cli (institutional) error"
        inst_claims_status="ERROR"; inst_merkle_status="ERROR"
      else
        # ---------- Compare institutional settlements -------------------------
        inst_claims_status="MATCH"
        inst_merkle_status="MATCH"

        # 1) Total claims amount
        local inst_exp_claims inst_act_claims
        inst_exp_claims=$(sum_claims "$expected_dir/institutional-distribution-settlements.json")
        inst_act_claims=$(sum_claims "$actual_dir/institutional-distribution-settlements.json")

        if [[ "$inst_exp_claims" == "null" || "$inst_act_claims" == "null" ]]; then
          echo "  INST ERROR: could not compute claim sums"
          inst_claims_status="ERROR"
        elif [[ "$inst_exp_claims" -ne "$inst_act_claims" ]]; then
          echo "  INST FAIL total claims: expected $inst_exp_claims, got $inst_act_claims"
          inst_claims_status="DIFFER"
        else
          echo "  INST OK total claims: $inst_act_claims lamports"
        fi

        # 2) Per-vote-account claims
        local inst_exp_per_vote inst_act_per_vote
        inst_exp_per_vote=$(per_vote_claims "$expected_dir/institutional-distribution-settlements.json")
        inst_act_per_vote=$(per_vote_claims "$actual_dir/institutional-distribution-settlements.json")

        if [[ "$inst_exp_per_vote" != "$inst_act_per_vote" ]]; then
          echo "  INST FAIL per-vote claims differ"
          [[ "$inst_claims_status" == "MATCH" ]] && inst_claims_status="DIFFER"
        else
          local inst_count
          inst_count=$(jq '.settlements | length' "$actual_dir/institutional-distribution-settlements.json")
          echo "  INST OK per-vote claims match ($inst_count settlements)"
        fi

        # 3) Merkle roots (should match exactly — no merging for institutional)
        local inst_exp_roots inst_act_roots
        inst_exp_roots=$(jq -S '[.merkle_trees[] | .merkle_root] | sort' \
          "$expected_dir/$inst_expected_merkle_name" 2>/dev/null || echo "ERROR")
        inst_act_roots=$(jq -S '[.merkle_trees[] | .merkle_root] | sort' \
          "$actual_dir/institutional-merkle-trees.json" 2>/dev/null || echo "ERROR")

        if [[ "$inst_exp_roots" == "ERROR" || "$inst_act_roots" == "ERROR" ]]; then
          echo "  INST ERROR: could not extract merkle roots"
          inst_merkle_status="ERROR"
        elif [[ "$inst_exp_roots" != "$inst_act_roots" ]]; then
          local inst_exp_root_count inst_act_root_count
          inst_exp_root_count=$(echo "$inst_exp_roots" | jq 'length')
          inst_act_root_count=$(echo "$inst_act_roots" | jq 'length')
          echo "  INST FAIL merkle roots: expected $inst_exp_root_count trees, got $inst_act_root_count"
          inst_merkle_status="DIFFER"
        else
          local inst_tree_count
          inst_tree_count=$(echo "$inst_act_roots" | jq 'length')
          echo "  INST OK merkle roots: all $inst_tree_count trees match"
        fi

        # 4) Per-funder amounts for institutional
        local inst_exp_funder inst_act_funder
        inst_exp_funder=$(per_vote_funder_claims "$expected_dir/institutional-distribution-settlements.json")
        inst_act_funder=$(merkle_tree_funding_sources "$actual_dir/institutional-merkle-trees.json")

        if [[ "$inst_exp_funder" == "null" || "$inst_act_funder" == "null" ]]; then
          echo "  INST WARN: could not compute per-funder amounts (skipping check)"
        elif [[ "$inst_exp_funder" != "$inst_act_funder" ]]; then
          local inst_funder_diff
          inst_funder_diff=$(diff \
            <(echo "$inst_exp_funder" | jq -r '.[] | "\(.vote_account) \(.funder) \(.total)"') \
            <(echo "$inst_act_funder" | jq -r '.[] | "\(.vote_account) \(.funder) \(.total)"') \
            | grep -c '^[<>]' || true)
          inst_funder_diff=$(( inst_funder_diff / 2 ))
          echo "  INST FAIL per-funder amounts: $inst_funder_diff entries differ"
          [[ "$inst_claims_status" == "MATCH" ]] && inst_claims_status="DIFFER"
        else
          local inst_funder_entries
          inst_funder_entries=$(echo "$inst_act_funder" | jq 'length')
          echo "  INST OK per-funder amounts: all $inst_funder_entries entries match"
        fi

        # 5) Funding integrity for institutional
        if ! check_funding_integrity "$actual_dir/institutional-merkle-trees.json" "INST "; then
          inst_merkle_status="DIFFER"
        fi
      fi
    fi
  fi

  # ------- Determine overall status ---------------------------------------

  local overall="PASS"
  for s in "$bid_claims_status" "$bid_merkle_status" "$inst_claims_status" "$inst_merkle_status"; do
    case "$s" in
      DIFFER|ERROR) overall="FAIL" ;;
    esac
  done

  results+=("$epoch $bid_claims_status $bid_merkle_status $inst_claims_status $inst_merkle_status $overall")
}

# ---------------------------------------------------------------------------
# Main loop
# ---------------------------------------------------------------------------
echo "Regression test: epochs $START_EPOCH .. $END_EPOCH"
echo "Data directory : $DATA_DIR"
echo "Scoring API    : $SCORING_API_URL"
echo ""

for (( epoch = START_EPOCH; epoch <= END_EPOCH; epoch++ )); do
  process_epoch "$epoch"
done

# ---------------------------------------------------------------------------
# Summary
# ---------------------------------------------------------------------------
echo ""
echo "================================================================"
echo "  Summary"
echo "================================================================"
printf "%-7s | %-11s | %-11s | %-11s | %-11s | %s\n" \
  "Epoch" "Bid Claims" "Bid Merkle" "Inst Claims" "Inst Merkle" "Status"
printf "%-7s-+-%-11s-+-%-11s-+-%-11s-+-%-11s-+-%s\n" \
  "-------" "-----------" "-----------" "-----------" "-----------" "------"

any_fail=false
for entry in "${results[@]}"; do
  read -r ep bc bm ic im status <<< "$entry"
  printf "%-7s | %-11s | %-11s | %-11s | %-11s | %s\n" "$ep" "$bc" "$bm" "$ic" "$im" "$status"
  if [[ "$status" == "FAIL" ]]; then
    any_fail=true
  fi
done

echo ""
if [[ "$any_fail" == "true" ]]; then
  echo "RESULT: SOME EPOCHS FAILED"
  exit 1
else
  echo "RESULT: ALL EPOCHS PASSED"
  exit 0
fi
