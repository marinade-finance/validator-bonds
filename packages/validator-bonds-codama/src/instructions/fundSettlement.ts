/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { VALIDATOR_BONDS_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const FUND_SETTLEMENT_DISCRIMINATOR = new Uint8Array([
  179, 146, 113, 34, 30, 92, 26, 19,
]);

export function getFundSettlementDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    FUND_SETTLEMENT_DISCRIMINATOR
  );
}

export type FundSettlementInstruction<
  TProgram extends string = typeof VALIDATOR_BONDS_PROGRAM_ADDRESS,
  TAccountConfig extends string | AccountMeta<string> = string,
  TAccountBond extends string | AccountMeta<string> = string,
  TAccountVoteAccount extends string | AccountMeta<string> = string,
  TAccountSettlement extends string | AccountMeta<string> = string,
  TAccountOperatorAuthority extends string | AccountMeta<string> = string,
  TAccountStakeAccount extends string | AccountMeta<string> = string,
  TAccountSettlementStakerAuthority extends
    | string
    | AccountMeta<string> = string,
  TAccountBondsWithdrawerAuthority extends
    | string
    | AccountMeta<string> = string,
  TAccountSplitStakeAccount extends string | AccountMeta<string> = string,
  TAccountSplitStakeRentPayer extends string | AccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TAccountStakeHistory extends string | AccountMeta<string> = string,
  TAccountClock extends string | AccountMeta<string> = string,
  TAccountRent extends
    | string
    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',
  TAccountStakeProgram extends string | AccountMeta<string> = string,
  TAccountStakeConfig extends string | AccountMeta<string> = string,
  TAccountEventAuthority extends string | AccountMeta<string> = string,
  TAccountProgram extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountConfig extends string
        ? ReadonlyAccount<TAccountConfig>
        : TAccountConfig,
      TAccountBond extends string
        ? ReadonlyAccount<TAccountBond>
        : TAccountBond,
      TAccountVoteAccount extends string
        ? ReadonlyAccount<TAccountVoteAccount>
        : TAccountVoteAccount,
      TAccountSettlement extends string
        ? WritableAccount<TAccountSettlement>
        : TAccountSettlement,
      TAccountOperatorAuthority extends string
        ? ReadonlySignerAccount<TAccountOperatorAuthority> &
            AccountSignerMeta<TAccountOperatorAuthority>
        : TAccountOperatorAuthority,
      TAccountStakeAccount extends string
        ? WritableAccount<TAccountStakeAccount>
        : TAccountStakeAccount,
      TAccountSettlementStakerAuthority extends string
        ? ReadonlyAccount<TAccountSettlementStakerAuthority>
        : TAccountSettlementStakerAuthority,
      TAccountBondsWithdrawerAuthority extends string
        ? ReadonlyAccount<TAccountBondsWithdrawerAuthority>
        : TAccountBondsWithdrawerAuthority,
      TAccountSplitStakeAccount extends string
        ? WritableSignerAccount<TAccountSplitStakeAccount> &
            AccountSignerMeta<TAccountSplitStakeAccount>
        : TAccountSplitStakeAccount,
      TAccountSplitStakeRentPayer extends string
        ? WritableSignerAccount<TAccountSplitStakeRentPayer> &
            AccountSignerMeta<TAccountSplitStakeRentPayer>
        : TAccountSplitStakeRentPayer,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountStakeHistory extends string
        ? ReadonlyAccount<TAccountStakeHistory>
        : TAccountStakeHistory,
      TAccountClock extends string
        ? ReadonlyAccount<TAccountClock>
        : TAccountClock,
      TAccountRent extends string
        ? ReadonlyAccount<TAccountRent>
        : TAccountRent,
      TAccountStakeProgram extends string
        ? ReadonlyAccount<TAccountStakeProgram>
        : TAccountStakeProgram,
      TAccountStakeConfig extends string
        ? ReadonlyAccount<TAccountStakeConfig>
        : TAccountStakeConfig,
      TAccountEventAuthority extends string
        ? ReadonlyAccount<TAccountEventAuthority>
        : TAccountEventAuthority,
      TAccountProgram extends string
        ? ReadonlyAccount<TAccountProgram>
        : TAccountProgram,
      ...TRemainingAccounts,
    ]
  >;

export type FundSettlementInstructionData = {
  discriminator: ReadonlyUint8Array;
};

export type FundSettlementInstructionDataArgs = {};

export function getFundSettlementInstructionDataEncoder(): FixedSizeEncoder<FundSettlementInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),
    (value) => ({ ...value, discriminator: FUND_SETTLEMENT_DISCRIMINATOR })
  );
}

export function getFundSettlementInstructionDataDecoder(): FixedSizeDecoder<FundSettlementInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
  ]);
}

export function getFundSettlementInstructionDataCodec(): FixedSizeCodec<
  FundSettlementInstructionDataArgs,
  FundSettlementInstructionData
> {
  return combineCodec(
    getFundSettlementInstructionDataEncoder(),
    getFundSettlementInstructionDataDecoder()
  );
}

export type FundSettlementInput<
  TAccountConfig extends string = string,
  TAccountBond extends string = string,
  TAccountVoteAccount extends string = string,
  TAccountSettlement extends string = string,
  TAccountOperatorAuthority extends string = string,
  TAccountStakeAccount extends string = string,
  TAccountSettlementStakerAuthority extends string = string,
  TAccountBondsWithdrawerAuthority extends string = string,
  TAccountSplitStakeAccount extends string = string,
  TAccountSplitStakeRentPayer extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountStakeHistory extends string = string,
  TAccountClock extends string = string,
  TAccountRent extends string = string,
  TAccountStakeProgram extends string = string,
  TAccountStakeConfig extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> = {
  config: Address<TAccountConfig>;
  bond: Address<TAccountBond>;
  voteAccount: Address<TAccountVoteAccount>;
  settlement: Address<TAccountSettlement>;
  /** operator signer authority is allowed to fund the settlement account */
  operatorAuthority: TransactionSigner<TAccountOperatorAuthority>;
  /** stake account to be funded into the settlement */
  stakeAccount: Address<TAccountStakeAccount>;
  /**
   * the settlement stake authority differentiates between deposited and funded stake accounts
   * deposited accounts have the bonds_withdrawer_authority, while funded accounts have the settlement_staker_authority
   */
  settlementStakerAuthority: Address<TAccountSettlementStakerAuthority>;
  /** authority that manages (owns) all stakes account under the bonds program */
  bondsWithdrawerAuthority: Address<TAccountBondsWithdrawerAuthority>;
  /**
   * if an account that does not exist is provided, it will be initialized as a stake account (with the necessary signature)
   * the split_stake_account is required when the provided stake_account contains more lamports than necessary to fund the settlement
   * in this case, the excess lamports from the stake account are split into the new split_stake_account,
   * if the split_stake_account is not needed, the rent payer is refunded back within tx
   */
  splitStakeAccount: TransactionSigner<TAccountSplitStakeAccount>;
  /**
   * the rent exempt payer of the split_stake_account creation
   * if the split_stake_account is not needed (no leftover lamports on funding), then the rent payer is refunded
   * if the split_stake_account is needed to spill out over funding of the settlement,
   * then the rent payer is refunded when the settlement is closed
   */
  splitStakeRentPayer: TransactionSigner<TAccountSplitStakeRentPayer>;
  systemProgram?: Address<TAccountSystemProgram>;
  stakeHistory: Address<TAccountStakeHistory>;
  clock: Address<TAccountClock>;
  rent?: Address<TAccountRent>;
  stakeProgram: Address<TAccountStakeProgram>;
  stakeConfig: Address<TAccountStakeConfig>;
  eventAuthority: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
};

export function getFundSettlementInstruction<
  TAccountConfig extends string,
  TAccountBond extends string,
  TAccountVoteAccount extends string,
  TAccountSettlement extends string,
  TAccountOperatorAuthority extends string,
  TAccountStakeAccount extends string,
  TAccountSettlementStakerAuthority extends string,
  TAccountBondsWithdrawerAuthority extends string,
  TAccountSplitStakeAccount extends string,
  TAccountSplitStakeRentPayer extends string,
  TAccountSystemProgram extends string,
  TAccountStakeHistory extends string,
  TAccountClock extends string,
  TAccountRent extends string,
  TAccountStakeProgram extends string,
  TAccountStakeConfig extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof VALIDATOR_BONDS_PROGRAM_ADDRESS,
>(
  input: FundSettlementInput<
    TAccountConfig,
    TAccountBond,
    TAccountVoteAccount,
    TAccountSettlement,
    TAccountOperatorAuthority,
    TAccountStakeAccount,
    TAccountSettlementStakerAuthority,
    TAccountBondsWithdrawerAuthority,
    TAccountSplitStakeAccount,
    TAccountSplitStakeRentPayer,
    TAccountSystemProgram,
    TAccountStakeHistory,
    TAccountClock,
    TAccountRent,
    TAccountStakeProgram,
    TAccountStakeConfig,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress }
): FundSettlementInstruction<
  TProgramAddress,
  TAccountConfig,
  TAccountBond,
  TAccountVoteAccount,
  TAccountSettlement,
  TAccountOperatorAuthority,
  TAccountStakeAccount,
  TAccountSettlementStakerAuthority,
  TAccountBondsWithdrawerAuthority,
  TAccountSplitStakeAccount,
  TAccountSplitStakeRentPayer,
  TAccountSystemProgram,
  TAccountStakeHistory,
  TAccountClock,
  TAccountRent,
  TAccountStakeProgram,
  TAccountStakeConfig,
  TAccountEventAuthority,
  TAccountProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? VALIDATOR_BONDS_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: false },
    bond: { value: input.bond ?? null, isWritable: false },
    voteAccount: { value: input.voteAccount ?? null, isWritable: false },
    settlement: { value: input.settlement ?? null, isWritable: true },
    operatorAuthority: {
      value: input.operatorAuthority ?? null,
      isWritable: false,
    },
    stakeAccount: { value: input.stakeAccount ?? null, isWritable: true },
    settlementStakerAuthority: {
      value: input.settlementStakerAuthority ?? null,
      isWritable: false,
    },
    bondsWithdrawerAuthority: {
      value: input.bondsWithdrawerAuthority ?? null,
      isWritable: false,
    },
    splitStakeAccount: {
      value: input.splitStakeAccount ?? null,
      isWritable: true,
    },
    splitStakeRentPayer: {
      value: input.splitStakeRentPayer ?? null,
      isWritable: true,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    stakeHistory: { value: input.stakeHistory ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    stakeProgram: { value: input.stakeProgram ?? null, isWritable: false },
    stakeConfig: { value: input.stakeConfig ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.rent.value) {
    accounts.rent.value =
      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.bond),
      getAccountMeta(accounts.voteAccount),
      getAccountMeta(accounts.settlement),
      getAccountMeta(accounts.operatorAuthority),
      getAccountMeta(accounts.stakeAccount),
      getAccountMeta(accounts.settlementStakerAuthority),
      getAccountMeta(accounts.bondsWithdrawerAuthority),
      getAccountMeta(accounts.splitStakeAccount),
      getAccountMeta(accounts.splitStakeRentPayer),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.stakeHistory),
      getAccountMeta(accounts.clock),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.stakeProgram),
      getAccountMeta(accounts.stakeConfig),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getFundSettlementInstructionDataEncoder().encode({}),
    programAddress,
  } as FundSettlementInstruction<
    TProgramAddress,
    TAccountConfig,
    TAccountBond,
    TAccountVoteAccount,
    TAccountSettlement,
    TAccountOperatorAuthority,
    TAccountStakeAccount,
    TAccountSettlementStakerAuthority,
    TAccountBondsWithdrawerAuthority,
    TAccountSplitStakeAccount,
    TAccountSplitStakeRentPayer,
    TAccountSystemProgram,
    TAccountStakeHistory,
    TAccountClock,
    TAccountRent,
    TAccountStakeProgram,
    TAccountStakeConfig,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export type ParsedFundSettlementInstruction<
  TProgram extends string = typeof VALIDATOR_BONDS_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    config: TAccountMetas[0];
    bond: TAccountMetas[1];
    voteAccount: TAccountMetas[2];
    settlement: TAccountMetas[3];
    /** operator signer authority is allowed to fund the settlement account */
    operatorAuthority: TAccountMetas[4];
    /** stake account to be funded into the settlement */
    stakeAccount: TAccountMetas[5];
    /**
     * the settlement stake authority differentiates between deposited and funded stake accounts
     * deposited accounts have the bonds_withdrawer_authority, while funded accounts have the settlement_staker_authority
     */
    settlementStakerAuthority: TAccountMetas[6];
    /** authority that manages (owns) all stakes account under the bonds program */
    bondsWithdrawerAuthority: TAccountMetas[7];
    /**
     * if an account that does not exist is provided, it will be initialized as a stake account (with the necessary signature)
     * the split_stake_account is required when the provided stake_account contains more lamports than necessary to fund the settlement
     * in this case, the excess lamports from the stake account are split into the new split_stake_account,
     * if the split_stake_account is not needed, the rent payer is refunded back within tx
     */
    splitStakeAccount: TAccountMetas[8];
    /**
     * the rent exempt payer of the split_stake_account creation
     * if the split_stake_account is not needed (no leftover lamports on funding), then the rent payer is refunded
     * if the split_stake_account is needed to spill out over funding of the settlement,
     * then the rent payer is refunded when the settlement is closed
     */
    splitStakeRentPayer: TAccountMetas[9];
    systemProgram: TAccountMetas[10];
    stakeHistory: TAccountMetas[11];
    clock: TAccountMetas[12];
    rent: TAccountMetas[13];
    stakeProgram: TAccountMetas[14];
    stakeConfig: TAccountMetas[15];
    eventAuthority: TAccountMetas[16];
    program: TAccountMetas[17];
  };
  data: FundSettlementInstructionData;
};

export function parseFundSettlementInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedFundSettlementInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 18) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      bond: getNextAccount(),
      voteAccount: getNextAccount(),
      settlement: getNextAccount(),
      operatorAuthority: getNextAccount(),
      stakeAccount: getNextAccount(),
      settlementStakerAuthority: getNextAccount(),
      bondsWithdrawerAuthority: getNextAccount(),
      splitStakeAccount: getNextAccount(),
      splitStakeRentPayer: getNextAccount(),
      systemProgram: getNextAccount(),
      stakeHistory: getNextAccount(),
      clock: getNextAccount(),
      rent: getNextAccount(),
      stakeProgram: getNextAccount(),
      stakeConfig: getNextAccount(),
      eventAuthority: getNextAccount(),
      program: getNextAccount(),
    },
    data: getFundSettlementInstructionDataDecoder().decode(instruction.data),
  };
}
