/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type Option,
  type OptionOrNullable,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getBumpsDecoder,
  getBumpsEncoder,
  type Bumps,
  type BumpsArgs,
} from '../types';

export const SETTLEMENT_DISCRIMINATOR = new Uint8Array([
  55, 11, 219, 33, 36, 136, 40, 182,
]);

export function getSettlementDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(SETTLEMENT_DISCRIMINATOR);
}

export type Settlement = {
  discriminator: ReadonlyUint8Array;
  /** the settlement belongs under this bond, i.e., under a particular validator vote account */
  bond: Address;
  /**
   * settlement authority used as the 'staker' stake account authority
   * of stake accounts funded to this settlement
   */
  stakerAuthority: Address;
  /** 256-bit merkle root to check the claims against */
  merkleRoot: ReadonlyUint8Array;
  /** maximum number of funds that can ever be claimed */
  maxTotalClaim: bigint;
  /** maximum number of merkle tree nodes that can ever be claimed */
  maxMerkleNodes: bigint;
  /** total lamports funded */
  lamportsFunded: bigint;
  /** total lamports that have been claimed */
  lamportsClaimed: bigint;
  /** number of nodes that have been claimed */
  merkleNodesClaimed: bigint;
  /** what epoch the Settlement has been created for */
  epochCreatedFor: bigint;
  /** when the Settlement was created */
  slotCreatedAt: bigint;
  /** address that collects the rent exempt from the Settlement account when closed */
  rentCollector: Address;
  /** address that collects rent exempt for "split stake account" possibly created on funding settlement */
  splitRentCollector: Option<Address>;
  /** amount of lamports that are collected for rent exempt for "split stake account" */
  splitRentAmount: bigint;
  /** PDA bumps */
  bumps: Bumps;
  /** reserve space for future extensions */
  reserved: ReadonlyUint8Array;
};

export type SettlementArgs = {
  /** the settlement belongs under this bond, i.e., under a particular validator vote account */
  bond: Address;
  /**
   * settlement authority used as the 'staker' stake account authority
   * of stake accounts funded to this settlement
   */
  stakerAuthority: Address;
  /** 256-bit merkle root to check the claims against */
  merkleRoot: ReadonlyUint8Array;
  /** maximum number of funds that can ever be claimed */
  maxTotalClaim: number | bigint;
  /** maximum number of merkle tree nodes that can ever be claimed */
  maxMerkleNodes: number | bigint;
  /** total lamports funded */
  lamportsFunded: number | bigint;
  /** total lamports that have been claimed */
  lamportsClaimed: number | bigint;
  /** number of nodes that have been claimed */
  merkleNodesClaimed: number | bigint;
  /** what epoch the Settlement has been created for */
  epochCreatedFor: number | bigint;
  /** when the Settlement was created */
  slotCreatedAt: number | bigint;
  /** address that collects the rent exempt from the Settlement account when closed */
  rentCollector: Address;
  /** address that collects rent exempt for "split stake account" possibly created on funding settlement */
  splitRentCollector: OptionOrNullable<Address>;
  /** amount of lamports that are collected for rent exempt for "split stake account" */
  splitRentAmount: number | bigint;
  /** PDA bumps */
  bumps: BumpsArgs;
  /** reserve space for future extensions */
  reserved: ReadonlyUint8Array;
};

export function getSettlementEncoder(): Encoder<SettlementArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['bond', getAddressEncoder()],
      ['stakerAuthority', getAddressEncoder()],
      ['merkleRoot', fixEncoderSize(getBytesEncoder(), 32)],
      ['maxTotalClaim', getU64Encoder()],
      ['maxMerkleNodes', getU64Encoder()],
      ['lamportsFunded', getU64Encoder()],
      ['lamportsClaimed', getU64Encoder()],
      ['merkleNodesClaimed', getU64Encoder()],
      ['epochCreatedFor', getU64Encoder()],
      ['slotCreatedAt', getU64Encoder()],
      ['rentCollector', getAddressEncoder()],
      ['splitRentCollector', getOptionEncoder(getAddressEncoder())],
      ['splitRentAmount', getU64Encoder()],
      ['bumps', getBumpsEncoder()],
      ['reserved', fixEncoderSize(getBytesEncoder(), 90)],
    ]),
    (value) => ({ ...value, discriminator: SETTLEMENT_DISCRIMINATOR })
  );
}

export function getSettlementDecoder(): Decoder<Settlement> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['bond', getAddressDecoder()],
    ['stakerAuthority', getAddressDecoder()],
    ['merkleRoot', fixDecoderSize(getBytesDecoder(), 32)],
    ['maxTotalClaim', getU64Decoder()],
    ['maxMerkleNodes', getU64Decoder()],
    ['lamportsFunded', getU64Decoder()],
    ['lamportsClaimed', getU64Decoder()],
    ['merkleNodesClaimed', getU64Decoder()],
    ['epochCreatedFor', getU64Decoder()],
    ['slotCreatedAt', getU64Decoder()],
    ['rentCollector', getAddressDecoder()],
    ['splitRentCollector', getOptionDecoder(getAddressDecoder())],
    ['splitRentAmount', getU64Decoder()],
    ['bumps', getBumpsDecoder()],
    ['reserved', fixDecoderSize(getBytesDecoder(), 90)],
  ]);
}

export function getSettlementCodec(): Codec<SettlementArgs, Settlement> {
  return combineCodec(getSettlementEncoder(), getSettlementDecoder());
}

export function decodeSettlement<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<Settlement, TAddress>;
export function decodeSettlement<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<Settlement, TAddress>;
export function decodeSettlement<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<Settlement, TAddress> | MaybeAccount<Settlement, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getSettlementDecoder()
  );
}

export async function fetchSettlement<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<Settlement, TAddress>> {
  const maybeAccount = await fetchMaybeSettlement(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeSettlement<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<Settlement, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeSettlement(maybeAccount);
}

export async function fetchAllSettlement(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<Settlement>[]> {
  const maybeAccounts = await fetchAllMaybeSettlement(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeSettlement(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<Settlement>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeSettlement(maybeAccount));
}
