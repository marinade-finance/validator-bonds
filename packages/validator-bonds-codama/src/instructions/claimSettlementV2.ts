/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type IAccountMeta,
  type IInstruction,
  type IInstructionWithAccounts,
  type IInstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type WritableAccount,
} from '@solana/kit'
import { VALIDATOR_BONDS_PROGRAM_ADDRESS } from '../programs'
import { getAccountMetaFactory, type ResolvedAccount } from '../shared'

export const CLAIM_SETTLEMENT_V2_DISCRIMINATOR = new Uint8Array([
  188, 53, 132, 151, 88, 50, 52, 238,
])

export function getClaimSettlementV2DiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CLAIM_SETTLEMENT_V2_DISCRIMINATOR,
  )
}

export type ClaimSettlementV2Instruction<
  TProgram extends string = typeof VALIDATOR_BONDS_PROGRAM_ADDRESS,
  TAccountConfig extends string | IAccountMeta<string> = string,
  TAccountBond extends string | IAccountMeta<string> = string,
  TAccountSettlement extends string | IAccountMeta<string> = string,
  TAccountSettlementClaims extends string | IAccountMeta<string> = string,
  TAccountStakeAccountFrom extends string | IAccountMeta<string> = string,
  TAccountStakeAccountTo extends string | IAccountMeta<string> = string,
  TAccountBondsWithdrawerAuthority extends
    | string
    | IAccountMeta<string> = string,
  TAccountStakeHistory extends string | IAccountMeta<string> = string,
  TAccountClock extends string | IAccountMeta<string> = string,
  TAccountStakeProgram extends string | IAccountMeta<string> = string,
  TAccountEventAuthority extends string | IAccountMeta<string> = string,
  TAccountProgram extends string | IAccountMeta<string> = string,
  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
  IInstructionWithData<Uint8Array> &
  IInstructionWithAccounts<
    [
      TAccountConfig extends string
        ? ReadonlyAccount<TAccountConfig>
        : TAccountConfig,
      TAccountBond extends string
        ? ReadonlyAccount<TAccountBond>
        : TAccountBond,
      TAccountSettlement extends string
        ? WritableAccount<TAccountSettlement>
        : TAccountSettlement,
      TAccountSettlementClaims extends string
        ? WritableAccount<TAccountSettlementClaims>
        : TAccountSettlementClaims,
      TAccountStakeAccountFrom extends string
        ? WritableAccount<TAccountStakeAccountFrom>
        : TAccountStakeAccountFrom,
      TAccountStakeAccountTo extends string
        ? WritableAccount<TAccountStakeAccountTo>
        : TAccountStakeAccountTo,
      TAccountBondsWithdrawerAuthority extends string
        ? ReadonlyAccount<TAccountBondsWithdrawerAuthority>
        : TAccountBondsWithdrawerAuthority,
      TAccountStakeHistory extends string
        ? ReadonlyAccount<TAccountStakeHistory>
        : TAccountStakeHistory,
      TAccountClock extends string
        ? ReadonlyAccount<TAccountClock>
        : TAccountClock,
      TAccountStakeProgram extends string
        ? ReadonlyAccount<TAccountStakeProgram>
        : TAccountStakeProgram,
      TAccountEventAuthority extends string
        ? ReadonlyAccount<TAccountEventAuthority>
        : TAccountEventAuthority,
      TAccountProgram extends string
        ? ReadonlyAccount<TAccountProgram>
        : TAccountProgram,
      ...TRemainingAccounts,
    ]
  >

export type ClaimSettlementV2InstructionData = {
  discriminator: ReadonlyUint8Array
  /** proof that the claim is appropriate */
  proof: Array<ReadonlyUint8Array>
  treeNodeHash: ReadonlyUint8Array
  /** staker authority of the stake_account_to; merkle root verification */
  stakeAccountStaker: Address
  /** withdrawer authority of the stake_account_to; merkle root verification */
  stakeAccountWithdrawer: Address
  /** claim amount; merkle root verification */
  claim: bigint
  /** index, ordered claim record in the settlement list; merkle root verification */
  index: bigint
}

export type ClaimSettlementV2InstructionDataArgs = {
  /** proof that the claim is appropriate */
  proof: Array<ReadonlyUint8Array>
  treeNodeHash: ReadonlyUint8Array
  /** staker authority of the stake_account_to; merkle root verification */
  stakeAccountStaker: Address
  /** withdrawer authority of the stake_account_to; merkle root verification */
  stakeAccountWithdrawer: Address
  /** claim amount; merkle root verification */
  claim: number | bigint
  /** index, ordered claim record in the settlement list; merkle root verification */
  index: number | bigint
}

export function getClaimSettlementV2InstructionDataEncoder(): Encoder<ClaimSettlementV2InstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['proof', getArrayEncoder(fixEncoderSize(getBytesEncoder(), 32))],
      ['treeNodeHash', fixEncoderSize(getBytesEncoder(), 32)],
      ['stakeAccountStaker', getAddressEncoder()],
      ['stakeAccountWithdrawer', getAddressEncoder()],
      ['claim', getU64Encoder()],
      ['index', getU64Encoder()],
    ]),
    value => ({ ...value, discriminator: CLAIM_SETTLEMENT_V2_DISCRIMINATOR }),
  )
}

export function getClaimSettlementV2InstructionDataDecoder(): Decoder<ClaimSettlementV2InstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['proof', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 32))],
    ['treeNodeHash', fixDecoderSize(getBytesDecoder(), 32)],
    ['stakeAccountStaker', getAddressDecoder()],
    ['stakeAccountWithdrawer', getAddressDecoder()],
    ['claim', getU64Decoder()],
    ['index', getU64Decoder()],
  ])
}

export function getClaimSettlementV2InstructionDataCodec(): Codec<
  ClaimSettlementV2InstructionDataArgs,
  ClaimSettlementV2InstructionData
> {
  return combineCodec(
    getClaimSettlementV2InstructionDataEncoder(),
    getClaimSettlementV2InstructionDataDecoder(),
  )
}

export type ClaimSettlementV2Input<
  TAccountConfig extends string = string,
  TAccountBond extends string = string,
  TAccountSettlement extends string = string,
  TAccountSettlementClaims extends string = string,
  TAccountStakeAccountFrom extends string = string,
  TAccountStakeAccountTo extends string = string,
  TAccountBondsWithdrawerAuthority extends string = string,
  TAccountStakeHistory extends string = string,
  TAccountClock extends string = string,
  TAccountStakeProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> = {
  /** the config account under which the settlement was created */
  config: Address<TAccountConfig>
  bond: Address<TAccountBond>
  settlement: Address<TAccountSettlement>
  /** deduplication, merkle tree record cannot be claimed twice */
  settlementClaims: Address<TAccountSettlementClaims>
  /** a stake account that will be withdrawn */
  stakeAccountFrom: Address<TAccountStakeAccountFrom>
  /** a stake account that will receive the funds */
  stakeAccountTo: Address<TAccountStakeAccountTo>
  /** authority that manages (owns == by being withdrawer authority) all stakes account under the bonds program */
  bondsWithdrawerAuthority: Address<TAccountBondsWithdrawerAuthority>
  stakeHistory: Address<TAccountStakeHistory>
  clock: Address<TAccountClock>
  stakeProgram: Address<TAccountStakeProgram>
  eventAuthority: Address<TAccountEventAuthority>
  program: Address<TAccountProgram>
  proof: ClaimSettlementV2InstructionDataArgs['proof']
  treeNodeHash: ClaimSettlementV2InstructionDataArgs['treeNodeHash']
  stakeAccountStaker: ClaimSettlementV2InstructionDataArgs['stakeAccountStaker']
  stakeAccountWithdrawer: ClaimSettlementV2InstructionDataArgs['stakeAccountWithdrawer']
  claim: ClaimSettlementV2InstructionDataArgs['claim']
  index: ClaimSettlementV2InstructionDataArgs['index']
}

export function getClaimSettlementV2Instruction<
  TAccountConfig extends string,
  TAccountBond extends string,
  TAccountSettlement extends string,
  TAccountSettlementClaims extends string,
  TAccountStakeAccountFrom extends string,
  TAccountStakeAccountTo extends string,
  TAccountBondsWithdrawerAuthority extends string,
  TAccountStakeHistory extends string,
  TAccountClock extends string,
  TAccountStakeProgram extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof VALIDATOR_BONDS_PROGRAM_ADDRESS,
>(
  input: ClaimSettlementV2Input<
    TAccountConfig,
    TAccountBond,
    TAccountSettlement,
    TAccountSettlementClaims,
    TAccountStakeAccountFrom,
    TAccountStakeAccountTo,
    TAccountBondsWithdrawerAuthority,
    TAccountStakeHistory,
    TAccountClock,
    TAccountStakeProgram,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress },
): ClaimSettlementV2Instruction<
  TProgramAddress,
  TAccountConfig,
  TAccountBond,
  TAccountSettlement,
  TAccountSettlementClaims,
  TAccountStakeAccountFrom,
  TAccountStakeAccountTo,
  TAccountBondsWithdrawerAuthority,
  TAccountStakeHistory,
  TAccountClock,
  TAccountStakeProgram,
  TAccountEventAuthority,
  TAccountProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? VALIDATOR_BONDS_PROGRAM_ADDRESS

  // Original accounts.
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: false },
    bond: { value: input.bond ?? null, isWritable: false },
    settlement: { value: input.settlement ?? null, isWritable: true },
    settlementClaims: {
      value: input.settlementClaims ?? null,
      isWritable: true,
    },
    stakeAccountFrom: {
      value: input.stakeAccountFrom ?? null,
      isWritable: true,
    },
    stakeAccountTo: { value: input.stakeAccountTo ?? null, isWritable: true },
    bondsWithdrawerAuthority: {
      value: input.bondsWithdrawerAuthority ?? null,
      isWritable: false,
    },
    stakeHistory: { value: input.stakeHistory ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false },
    stakeProgram: { value: input.stakeProgram ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  }
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >

  // Original args.
  const args = { ...input }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId')
  const instruction = {
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.bond),
      getAccountMeta(accounts.settlement),
      getAccountMeta(accounts.settlementClaims),
      getAccountMeta(accounts.stakeAccountFrom),
      getAccountMeta(accounts.stakeAccountTo),
      getAccountMeta(accounts.bondsWithdrawerAuthority),
      getAccountMeta(accounts.stakeHistory),
      getAccountMeta(accounts.clock),
      getAccountMeta(accounts.stakeProgram),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    programAddress,
    data: getClaimSettlementV2InstructionDataEncoder().encode(
      args as ClaimSettlementV2InstructionDataArgs,
    ),
  } as ClaimSettlementV2Instruction<
    TProgramAddress,
    TAccountConfig,
    TAccountBond,
    TAccountSettlement,
    TAccountSettlementClaims,
    TAccountStakeAccountFrom,
    TAccountStakeAccountTo,
    TAccountBondsWithdrawerAuthority,
    TAccountStakeHistory,
    TAccountClock,
    TAccountStakeProgram,
    TAccountEventAuthority,
    TAccountProgram
  >

  return instruction
}

export type ParsedClaimSettlementV2Instruction<
  TProgram extends string = typeof VALIDATOR_BONDS_PROGRAM_ADDRESS,
  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
  programAddress: Address<TProgram>
  accounts: {
    /** the config account under which the settlement was created */
    config: TAccountMetas[0]
    bond: TAccountMetas[1]
    settlement: TAccountMetas[2]
    /** deduplication, merkle tree record cannot be claimed twice */
    settlementClaims: TAccountMetas[3]
    /** a stake account that will be withdrawn */
    stakeAccountFrom: TAccountMetas[4]
    /** a stake account that will receive the funds */
    stakeAccountTo: TAccountMetas[5]
    /** authority that manages (owns == by being withdrawer authority) all stakes account under the bonds program */
    bondsWithdrawerAuthority: TAccountMetas[6]
    stakeHistory: TAccountMetas[7]
    clock: TAccountMetas[8]
    stakeProgram: TAccountMetas[9]
    eventAuthority: TAccountMetas[10]
    program: TAccountMetas[11]
  }
  data: ClaimSettlementV2InstructionData
}

export function parseClaimSettlementV2Instruction<
  TProgram extends string,
  TAccountMetas extends readonly IAccountMeta[],
>(
  instruction: IInstruction<TProgram> &
    IInstructionWithAccounts<TAccountMetas> &
    IInstructionWithData<Uint8Array>,
): ParsedClaimSettlementV2Instruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 12) {
    // TODO: Coded error.
    throw new Error('Not enough accounts')
  }
  let accountIndex = 0
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!
    accountIndex += 1
    return accountMeta
  }
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      bond: getNextAccount(),
      settlement: getNextAccount(),
      settlementClaims: getNextAccount(),
      stakeAccountFrom: getNextAccount(),
      stakeAccountTo: getNextAccount(),
      bondsWithdrawerAuthority: getNextAccount(),
      stakeHistory: getNextAccount(),
      clock: getNextAccount(),
      stakeProgram: getNextAccount(),
      eventAuthority: getNextAccount(),
      program: getNextAccount(),
    },
    data: getClaimSettlementV2InstructionDataDecoder().decode(instruction.data),
  }
}
