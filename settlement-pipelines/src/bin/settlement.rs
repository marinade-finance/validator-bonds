use anchor_client::anchor_lang::AccountDeserialize;
use anchor_client::solana_client::rpc_config::RpcSendTransactionConfig;
use anchor_client::{Client, Cluster, DynSigner};
use anyhow::anyhow;
use clap::Parser;
use env_logger::{Builder, Env};
use log::{debug, error, info};
use marinade_transactions::transaction_builder::TransactionBuilder;
use marinade_transactions::transaction_executors::execute_transaction_builder;
use regex::Regex;
use settlement_engine::merkle_tree_collection::MerkleTreeCollection;
use settlement_engine::utils::read_from_json_file;
use settlement_pipelines::arguments::load_default_keypair;
use settlement_pipelines::constants::find_event_authority;
use settlement_pipelines::{
    arguments::{load_keypair, GlobalOpts},
    constants::MARINADE_CONFIG_ADDRESS,
};
use solana_sdk::commitment_config::{CommitmentConfig, CommitmentLevel};
use solana_sdk::pubkey::Pubkey;
use solana_sdk::system_program;
use std::path::Path;
use std::rc::Rc;
use std::str::FromStr;
use validator_bonds::instructions::InitSettlementArgs;
use validator_bonds::state::bond::Bond;
use validator_bonds::state::settlement::Settlement;
use validator_bonds::ID as validator_bonds_id;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[arg(
        short = 'i',
        long,
        env,
        help = "Merkle tree collection file path generated by settlement-engine as of --output-merkle-tree-collection"
    )]
    input_merkle_tree_collection: String,

    #[arg(long, default_value = MARINADE_CONFIG_ADDRESS)]
    config: Pubkey,

    #[arg(long)]
    epoch: Option<u64>,

    #[arg(short = 'o', long)]
    operator_authority: Option<String>,

    #[clap(flatten)]
    global_opts: GlobalOpts,
}

fn main() -> anyhow::Result<()> {
    let args: Args = Args::parse();

    let verbosity = if args.global_opts.verbose {
        "debug"
    } else {
        "info"
    };
    let mut builder = Builder::from_env(Env::default().default_filter_or(verbosity));
    builder.init();

    info!(
        "Loading merkle tree at: '{}', validator-bonds config: {}",
        args.input_merkle_tree_collection, args.config
    );
    let merkle_tree_collection: MerkleTreeCollection =
        read_from_json_file(&args.input_merkle_tree_collection).map_err(|e| {
            anyhow!(
                "Cannot read merkle tree collection from file '{}': {}",
                args.input_merkle_tree_collection,
                e
            )
        })?;

    // Initialize the Anchor Solana client
    let rpc_url = args
        .global_opts
        .rpc_url
        .ok_or(anyhow!("RPC URL is required, provide --rpc-url argument"))?;
    let anchor_cluster = Cluster::from_str(&rpc_url)
        .map_err(|e| anyhow!("Could not parse JSON RPC url `{:?}`: {}", rpc_url, e))?;

    let default_keypair = load_default_keypair(args.global_opts.keypair.as_deref())?;
    let fee_payer_keypair = if let Some(fee_payer) = args.global_opts.fee_payer {
        load_keypair(&fee_payer)?
    } else {
        default_keypair.clone().map_or(Err(anyhow!("Neither --fee-payer nor --keypair provided, no keypair to pay for transaction fees")), Ok)?
    };
    let operator_authority_keypair = if let Some(operator_authority) = args.operator_authority {
        load_keypair(&operator_authority)?
    } else {
        default_keypair.clone().map_or(
            Err(anyhow!(
                "Neither --operator-authority nor --keypair provided, operator keypair required"
            )),
            Ok,
        )?
    };

    let epoch = args.epoch.map_or_else(|| {
        let merkle_file_name = Path::new(&args.input_merkle_tree_collection).file_name().
            ok_or(anyhow!("Cannot extract file name from input merkle tree collection file path '{}'", args.input_merkle_tree_collection))?
            .to_str().ok_or(anyhow!("Cannot convert file name {} to string", args.input_merkle_tree_collection))?;
        let re = Regex::new("^([0-9]+)").unwrap();
        let captures = re.captures(merkle_file_name);
        captures
            .and_then(|c| c.get(0))
            .and_then(|m| m.as_str().parse::<u64>().ok())
            .ok_or(
                anyhow!("--epoch not provided and cannot extract epoch number from input merkle tree collection file path '{}'", args.input_merkle_tree_collection)
            )
    }, Ok)?;

    let fee_payer_pubkey = fee_payer_keypair.pubkey();
    let anchor_client = Client::new_with_options(
        anchor_cluster,
        Rc::new(DynSigner(fee_payer_keypair.clone())),
        CommitmentConfig::finalized(),
    );
    let program = anchor_client.program(validator_bonds_id)?;

    let mut vote_accounts: Vec<Pubkey> = Vec::new();
    let mut transaction_builder = TransactionBuilder::limited(fee_payer_keypair.clone());
    transaction_builder.add_signer_checked(&operator_authority_keypair.clone());

    // verify what are the settlement accounts that we need to create
    // (not to pushing many RPC calls to the network, squeezing them to less)
    let mut creation_records = merkle_tree_collection
        .merkle_trees
        .iter()
        .filter(|merkle_tree| {
            if merkle_tree.merkle_root.is_some() {
                true
            } else {
                error!(
                    "Cannot create for vote account {} without a merkle root",
                    merkle_tree.vote_account
                );
                false
            }
        })
        .map(|merkle_tree| {
            let merkle_root = merkle_tree.merkle_root.ok_or(anyhow!(
                "Cannot create for vote account {} without a merkle root",
                merkle_tree.vote_account
            ))?;
            let vote_account_address = merkle_tree.vote_account;
            let (bond_address, _) = validator_bonds::state::bond::find_bond_address(
                &args.config,
                &merkle_tree.vote_account,
            );
            let (settlement_address, _) =
                validator_bonds::state::settlement::find_settlement_address(
                    &bond_address,
                    &merkle_root.to_bytes(),
                    epoch,
                );
            Ok(CreationRecord {
                vote_account_address,
                bond_address,
                settlement_address,
                merkle_root: merkle_root.to_bytes(),
                max_total_claim: merkle_tree.max_total_claim_sum,
                max_merkle_nodes: merkle_tree.max_total_claims as u64,
                settlement_account: None,
                bond_account: None,
            })
        })
        .collect::<Result<Vec<CreationRecord>, anyhow::Error>>()?;

    // loading accounts from on-chain
    let settlement_addresses: Vec<Pubkey> = creation_records
        .iter()
        .map(|d| d.settlement_address)
        .collect();
    let settlement_accounts = program.rpc().get_multiple_accounts(&settlement_addresses)?;
    for (d, a) in creation_records.iter_mut().zip(settlement_accounts.iter()) {
        let settlement_account = if let Some(account) = a {
            let mut data: &[u8] = &account.data;
            Settlement::try_deserialize(&mut data).map_or_else(
                |e| {
                    error!(
                        "Cannot deserialize account data for settlement account {}: {}",
                        d.settlement_address, e
                    );
                    None
                },
                Some,
            )
        } else {
            None
        };
        d.settlement_account = settlement_account;
    }
    let bonds_addresses: Vec<Pubkey> = creation_records.iter().map(|d| d.bond_address).collect();
    let bond_accounts = program.rpc().get_multiple_accounts(&bonds_addresses)?;
    for (d, a) in creation_records.iter_mut().zip(bond_accounts.iter()) {
        let bond_account = if let Some(account) = a {
            let mut data: &[u8] = &account.data;
            Bond::try_deserialize(&mut data).map_or_else(
                |e| {
                    error!(
                        "Cannot deserialize account data for bond account {}: {}",
                        d.bond_address, e
                    );
                    None
                },
                Some,
            )
        } else {
            None
        };
        d.bond_account = bond_account;
    }

    for creation_record in creation_records {
        // TODO: what to do if bond account is not found?
        if creation_record.bond_account.is_none() {
            error!(
                "Cannot find bond account {} for vote account {}",
                creation_record.bond_address, creation_record.vote_account_address
            );
            continue;
        }
        if creation_record.settlement_account.is_some() {
            debug!(
                "Settlement account {} already exists, skipping initialization",
                creation_record.settlement_address
            );
            continue;
        }

        vote_accounts.push(creation_record.vote_account_address);
        let req = program
            .request()
            .accounts(validator_bonds::accounts::InitSettlement {
                config: args.config,
                bond: creation_record.bond_address,
                operator_authority: operator_authority_keypair.pubkey(),
                system_program: system_program::ID,
                rent_payer: fee_payer_pubkey,
                program: validator_bonds_id,
                settlement: creation_record.settlement_address,
                event_authority: find_event_authority().0,
            })
            .args(validator_bonds::instruction::InitSettlement {
                init_settlement_args: InitSettlementArgs {
                    merkle_root: creation_record.merkle_root,
                    rent_collector: fee_payer_pubkey,
                    max_total_claim: creation_record.max_total_claim,
                    max_merkle_nodes: creation_record.max_merkle_nodes,
                    epoch,
                },
            });
        transaction_builder
            .add_instructions_from_builder(req)
            .map_err(|e| anyhow!("Cannot add instruction to transaction builder: {}", e))?;
    }

    if transaction_builder.instructions().is_empty() {
        info!("No InitSettlement instructions to execute");
        return Ok(());
    } else {
        let execution_count = transaction_builder.instructions().len();
        info!(
            "Execution of {} InitSettlement instructions of vote accounts [{}]",
            execution_count,
            vote_accounts
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<String>>()
                .join(", ")
        );
        execute_transaction_builder(
            &mut transaction_builder,
            &program.rpc(),
            RpcSendTransactionConfig {
                skip_preflight: args.global_opts.skip_preflight,
                ..RpcSendTransactionConfig::default()
            },
            CommitmentLevel::Finalized,
            false,
            false,
            None,
        )?;
        info!(
            "InitSettlement instructions {} executed successfully",
            execution_count
        );
    }

    Ok(())
}

struct CreationRecord {
    vote_account_address: Pubkey,
    bond_address: Pubkey,
    settlement_address: Pubkey,
    settlement_account: Option<Settlement>,
    bond_account: Option<Bond>,
    merkle_root: [u8; 32],
    max_total_claim: u64,
    max_merkle_nodes: u64,
}
