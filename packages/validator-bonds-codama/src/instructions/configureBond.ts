/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/kit';
import { VALIDATOR_BONDS_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';

export const CONFIGURE_BOND_DISCRIMINATOR = new Uint8Array([
  228, 108, 79, 242, 82, 54, 105, 65,
]);

export function getConfigureBondDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CONFIGURE_BOND_DISCRIMINATOR
  );
}

export type ConfigureBondInstruction<
  TProgram extends string = typeof VALIDATOR_BONDS_PROGRAM_ADDRESS,
  TAccountConfig extends string | AccountMeta<string> = string,
  TAccountBond extends string | AccountMeta<string> = string,
  TAccountAuthority extends string | AccountMeta<string> = string,
  TAccountVoteAccount extends string | AccountMeta<string> = string,
  TAccountEventAuthority extends string | AccountMeta<string> = string,
  TAccountProgram extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountConfig extends string
        ? ReadonlyAccount<TAccountConfig>
        : TAccountConfig,
      TAccountBond extends string
        ? WritableAccount<TAccountBond>
        : TAccountBond,
      TAccountAuthority extends string
        ? ReadonlySignerAccount<TAccountAuthority> &
            AccountSignerMeta<TAccountAuthority>
        : TAccountAuthority,
      TAccountVoteAccount extends string
        ? ReadonlyAccount<TAccountVoteAccount>
        : TAccountVoteAccount,
      TAccountEventAuthority extends string
        ? ReadonlyAccount<TAccountEventAuthority>
        : TAccountEventAuthority,
      TAccountProgram extends string
        ? ReadonlyAccount<TAccountProgram>
        : TAccountProgram,
      ...TRemainingAccounts,
    ]
  >;

export type ConfigureBondInstructionData = {
  discriminator: ReadonlyUint8Array;
  /** New bond authority that can manage the bond account. */
  bondAuthority: Option<Address>;
  /**
   * New `cpmpe` value (cost per mille per epoch).
   * It defines the bid for the validator to get delegated up to `max_stake_wanted` lamports.
   */
  cpmpe: Option<bigint>;
  /**
   * New `max_stake_wanted` value that the vote account owner declares
   * as the maximum delegated stake desired.
   */
  maxStakeWanted: Option<bigint>;
};

export type ConfigureBondInstructionDataArgs = {
  /** New bond authority that can manage the bond account. */
  bondAuthority: OptionOrNullable<Address>;
  /**
   * New `cpmpe` value (cost per mille per epoch).
   * It defines the bid for the validator to get delegated up to `max_stake_wanted` lamports.
   */
  cpmpe: OptionOrNullable<number | bigint>;
  /**
   * New `max_stake_wanted` value that the vote account owner declares
   * as the maximum delegated stake desired.
   */
  maxStakeWanted: OptionOrNullable<number | bigint>;
};

export function getConfigureBondInstructionDataEncoder(): Encoder<ConfigureBondInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['bondAuthority', getOptionEncoder(getAddressEncoder())],
      ['cpmpe', getOptionEncoder(getU64Encoder())],
      ['maxStakeWanted', getOptionEncoder(getU64Encoder())],
    ]),
    (value) => ({ ...value, discriminator: CONFIGURE_BOND_DISCRIMINATOR })
  );
}

export function getConfigureBondInstructionDataDecoder(): Decoder<ConfigureBondInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['bondAuthority', getOptionDecoder(getAddressDecoder())],
    ['cpmpe', getOptionDecoder(getU64Decoder())],
    ['maxStakeWanted', getOptionDecoder(getU64Decoder())],
  ]);
}

export function getConfigureBondInstructionDataCodec(): Codec<
  ConfigureBondInstructionDataArgs,
  ConfigureBondInstructionData
> {
  return combineCodec(
    getConfigureBondInstructionDataEncoder(),
    getConfigureBondInstructionDataDecoder()
  );
}

export type ConfigureBondAsyncInput<
  TAccountConfig extends string = string,
  TAccountBond extends string = string,
  TAccountAuthority extends string = string,
  TAccountVoteAccount extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> = {
  config: Address<TAccountConfig>;
  bond?: Address<TAccountBond>;
  /** validator vote account validator identity or bond authority may change the account */
  authority: TransactionSigner<TAccountAuthority>;
  voteAccount: Address<TAccountVoteAccount>;
  eventAuthority?: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
  bondAuthority: ConfigureBondInstructionDataArgs['bondAuthority'];
  cpmpe: ConfigureBondInstructionDataArgs['cpmpe'];
  maxStakeWanted: ConfigureBondInstructionDataArgs['maxStakeWanted'];
};

export async function getConfigureBondInstructionAsync<
  TAccountConfig extends string,
  TAccountBond extends string,
  TAccountAuthority extends string,
  TAccountVoteAccount extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof VALIDATOR_BONDS_PROGRAM_ADDRESS,
>(
  input: ConfigureBondAsyncInput<
    TAccountConfig,
    TAccountBond,
    TAccountAuthority,
    TAccountVoteAccount,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  ConfigureBondInstruction<
    TProgramAddress,
    TAccountConfig,
    TAccountBond,
    TAccountAuthority,
    TAccountVoteAccount,
    TAccountEventAuthority,
    TAccountProgram
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? VALIDATOR_BONDS_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: false },
    bond: { value: input.bond ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    voteAccount: { value: input.voteAccount ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.bond.value) {
    accounts.bond.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            98, 111, 110, 100, 95, 97, 99, 99, 111, 117, 110, 116,
          ])
        ),
        getAddressEncoder().encode(expectAddress(accounts.config.value)),
        getAddressEncoder().encode(expectAddress(accounts.voteAccount.value)),
      ],
    });
  }
  if (!accounts.eventAuthority.value) {
    accounts.eventAuthority.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111, 114,
            105, 116, 121,
          ])
        ),
      ],
    });
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.bond),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.voteAccount),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getConfigureBondInstructionDataEncoder().encode(
      args as ConfigureBondInstructionDataArgs
    ),
    programAddress,
  } as ConfigureBondInstruction<
    TProgramAddress,
    TAccountConfig,
    TAccountBond,
    TAccountAuthority,
    TAccountVoteAccount,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export type ConfigureBondInput<
  TAccountConfig extends string = string,
  TAccountBond extends string = string,
  TAccountAuthority extends string = string,
  TAccountVoteAccount extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> = {
  config: Address<TAccountConfig>;
  bond: Address<TAccountBond>;
  /** validator vote account validator identity or bond authority may change the account */
  authority: TransactionSigner<TAccountAuthority>;
  voteAccount: Address<TAccountVoteAccount>;
  eventAuthority: Address<TAccountEventAuthority>;
  program: Address<TAccountProgram>;
  bondAuthority: ConfigureBondInstructionDataArgs['bondAuthority'];
  cpmpe: ConfigureBondInstructionDataArgs['cpmpe'];
  maxStakeWanted: ConfigureBondInstructionDataArgs['maxStakeWanted'];
};

export function getConfigureBondInstruction<
  TAccountConfig extends string,
  TAccountBond extends string,
  TAccountAuthority extends string,
  TAccountVoteAccount extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof VALIDATOR_BONDS_PROGRAM_ADDRESS,
>(
  input: ConfigureBondInput<
    TAccountConfig,
    TAccountBond,
    TAccountAuthority,
    TAccountVoteAccount,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress }
): ConfigureBondInstruction<
  TProgramAddress,
  TAccountConfig,
  TAccountBond,
  TAccountAuthority,
  TAccountVoteAccount,
  TAccountEventAuthority,
  TAccountProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? VALIDATOR_BONDS_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: false },
    bond: { value: input.bond ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    voteAccount: { value: input.voteAccount ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.bond),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.voteAccount),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    data: getConfigureBondInstructionDataEncoder().encode(
      args as ConfigureBondInstructionDataArgs
    ),
    programAddress,
  } as ConfigureBondInstruction<
    TProgramAddress,
    TAccountConfig,
    TAccountBond,
    TAccountAuthority,
    TAccountVoteAccount,
    TAccountEventAuthority,
    TAccountProgram
  >);
}

export type ParsedConfigureBondInstruction<
  TProgram extends string = typeof VALIDATOR_BONDS_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    config: TAccountMetas[0];
    bond: TAccountMetas[1];
    /** validator vote account validator identity or bond authority may change the account */
    authority: TAccountMetas[2];
    voteAccount: TAccountMetas[3];
    eventAuthority: TAccountMetas[4];
    program: TAccountMetas[5];
  };
  data: ConfigureBondInstructionData;
};

export function parseConfigureBondInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedConfigureBondInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 6) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      bond: getNextAccount(),
      authority: getNextAccount(),
      voteAccount: getNextAccount(),
      eventAuthority: getNextAccount(),
      program: getNextAccount(),
    },
    data: getConfigureBondInstructionDataDecoder().decode(instruction.data),
  };
}
